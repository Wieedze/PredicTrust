{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/PredictionFactoryTTrustSimple.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { TTrustMarketCapPredictionTTrust } from \"./TTrustMarketCapPredictionTTrust.sol\";\nimport { TTrustPriceOracle } from \"./TTrustPriceOracle.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title PredictionFactoryTTrustSimple\n * @notice Simplified factory contract for creating TTrust-based prediction markets\n */\ncontract PredictionFactoryTTrustSimple is Ownable {\n    \n    enum PredictionType {\n        MARKET_CAP_ABOVE,\n        MARKET_CAP_BELOW,\n        PRICE_ABOVE,\n        PRICE_BELOW\n    }\n    \n    // TTrust token contract\n    IERC20 public immutable ttrustToken;\n    \n    // Oracle\n    TTrustPriceOracle public ttustPriceOracle;\n    \n    // Simple market registry\n    address[] public allMarkets;\n    uint256 public marketCount;\n    \n    // Settings\n    uint256 public minimumLiquidity = 1e17; // 0.1 TTrust minimum\n    uint256 public creationFee = 1e15; // 0.001 TTrust creation fee\n    \n    event TTrustMarketCreated(\n        address indexed marketAddress,\n        address indexed creator,\n        PredictionType indexed predictionType,\n        uint256 targetValue,\n        uint256 deadline,\n        string description\n    );\n    \n    modifier validLiquidity(uint256 _liquidity) {\n        require(_liquidity >= minimumLiquidity, \"Insufficient liquidity\");\n        _;\n    }\n    \n    modifier validDeadline(uint256 _deadline) {\n        require(_deadline > block.timestamp, \"Invalid deadline\");\n        _;\n    }\n    \n    constructor(\n        address _owner,\n        address _ttrustToken,\n        address _ttustPriceOracle\n    ) Ownable(_owner) {\n        ttrustToken = IERC20(_ttrustToken);\n        \n        if (_ttustPriceOracle != address(0)) {\n            ttustPriceOracle = TTrustPriceOracle(_ttustPriceOracle);\n        }\n    }\n    \n    /**\n     * @notice Create a new TTrust prediction market\n     */\n    function createTTrustMarket(\n        PredictionType _predictionType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _customTokenValue,\n        uint8 _customProbability\n    )\n        external\n        payable\n        validLiquidity(msg.value)\n        validDeadline(_deadline)\n        returns (address marketAddress)\n    {\n        require(address(ttustPriceOracle) != address(0), \"Oracle not set\");\n        require(_targetValue > 0, \"Invalid target value\");\n        \n        // Calculate liquidity\n        uint256 actualLiquidity = msg.value - creationFee;\n        \n        // Create the market\n        TTrustMarketCapPredictionTTrust.PredictionType contractPredictionType;\n        \n        if (_predictionType == PredictionType.MARKET_CAP_ABOVE) {\n            contractPredictionType = TTrustMarketCapPredictionTTrust.PredictionType.MARKET_CAP_ABOVE;\n        } else if (_predictionType == PredictionType.MARKET_CAP_BELOW) {\n            contractPredictionType = TTrustMarketCapPredictionTTrust.PredictionType.MARKET_CAP_BELOW;\n        } else if (_predictionType == PredictionType.PRICE_ABOVE) {\n            contractPredictionType = TTrustMarketCapPredictionTTrust.PredictionType.PRICE_ABOVE;\n        } else {\n            contractPredictionType = TTrustMarketCapPredictionTTrust.PredictionType.PRICE_BELOW;\n        }\n        \n        TTrustMarketCapPredictionTTrust market = new TTrustMarketCapPredictionTTrust(\n            msg.sender,\n            address(ttustPriceOracle),\n            address(ttrustToken),\n            contractPredictionType,\n            _targetValue,\n            _deadline,\n            _description,\n            _customTokenValue > 0 ? _customTokenValue : 1e16, // Default 0.01 TTrust\n            _customProbability > 0 ? _customProbability : 50, // Default 50%\n            20, // Default 20% locked\n            actualLiquidity\n        );\n        \n        marketAddress = address(market);\n        \n        // Register market\n        allMarkets.push(marketAddress);\n        marketCount++;\n        \n        emit TTrustMarketCreated(\n            marketAddress,\n            msg.sender,\n            _predictionType,\n            _targetValue,\n            _deadline,\n            _description\n        );\n    }\n    \n    /**\n     * @notice Get market count\n     */\n    function getMarketCount() external view returns (uint256) {\n        return marketCount;\n    }\n    \n    /**\n     * @notice Get active markets (simple pagination)\n     */\n    function getActiveMarkets(uint256 _offset, uint256 _limit) \n        external \n        view \n        returns (address[] memory markets, uint256 total) \n    {\n        total = marketCount;\n        \n        if (_offset >= total) {\n            return (new address[](0), total);\n        }\n        \n        uint256 end = _offset + _limit;\n        if (end > total) {\n            end = total;\n        }\n        \n        markets = new address[](end - _offset);\n        for (uint256 i = _offset; i < end; i++) {\n            markets[i - _offset] = allMarkets[i];\n        }\n    }\n    \n    /**\n     * @notice Set oracle address\n     */\n    function setTTrustPriceOracle(address _oracle) external onlyOwner {\n        ttustPriceOracle = TTrustPriceOracle(_oracle);\n    }\n    \n    /**\n     * @notice Update fees\n     */\n    function setCreationFee(uint256 _fee) external onlyOwner {\n        creationFee = _fee;\n    }\n    \n    /**\n     * @notice Withdraw collected fees\n     */\n    function withdrawFees() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n}"
    },
    "contracts/PredictionMarketToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title PredictionMarketToken\n * @notice Simple ERC20 token for YES/NO prediction outcomes\n */\ncontract PredictionMarketToken is ERC20, Ownable {\n    \n    constructor(\n        string memory name,\n        string memory symbol,\n        address owner,\n        uint256 initialSupply\n    ) ERC20(name, symbol) Ownable(owner) {\n        _mint(owner, initialSupply);\n    }\n    \n    /**\n     * @notice Mint tokens (only owner can mint)\n     */\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n    \n    /**\n     * @notice Burn tokens (only owner can burn)\n     */\n    function burn(address from, uint256 amount) external onlyOwner {\n        _burn(from, amount);\n    }\n}"
    },
    "contracts/PredictionMarketTTrust.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { PredictionMarketToken } from \"./PredictionMarketToken.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PredictionMarketTTrust is Ownable {\n    /////////////////\n    /// Errors //////\n    /////////////////\n\n    error PredictionMarketTTrust__MustProvideTTrustForInitialLiquidity();\n    error PredictionMarketTTrust__InvalidProbability();\n    error PredictionMarketTTrust__PredictionAlreadyReported();\n    error PredictionMarketTTrust__OnlyOracleCanReport();\n    error PredictionMarketTTrust__OwnerCannotCall();\n    error PredictionMarketTTrust__PredictionNotReported();\n    error PredictionMarketTTrust__InsufficientWinningTokens();\n    error PredictionMarketTTrust__AmountMustBeGreaterThanZero();\n    error PredictionMarketTTrust__InsufficientTokenReserve(Outcome _outcome, uint256 _amountToken);\n    error PredictionMarketTTrust__TokenTransferFailed();\n    error PredictionMarketTTrust__TTrustTransferFailed();\n    error PredictionMarketTTrust__InsufficientBalance(uint256 _tradingAmount, uint256 _userBalance);\n    error PredictionMarketTTrust__InsufficientAllowance(uint256 _tradingAmount, uint256 _allowance);\n    error PredictionMarketTTrust__InsufficientLiquidity();\n    error PredictionMarketTTrust__InvalidPercentageToLock();\n    error PredictionMarketTTrust__InsufficientTTrustAllowance();\n\n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n\n    enum Outcome {\n        YES,\n        NO\n    }\n\n    uint256 private constant PRECISION = 1e18;\n\n    /// TTrust token contract\n    IERC20 public immutable i_ttrustToken;\n\n    /// Checkpoint 2 ///\n    address public immutable i_oracle;\n    uint256 public immutable i_initialTokenValue;\n    uint256 public immutable i_percentageLocked;\n    uint256 public immutable i_initialYesProbability;\n\n    string public s_question;\n    uint256 public s_ttrustCollateral;\n    uint256 public s_lpTradingRevenue;\n\n    /// Checkpoint 3 ///\n    PredictionMarketToken public immutable i_yesToken;\n    PredictionMarketToken public immutable i_noToken;\n\n    /// Checkpoint 5 ///\n    PredictionMarketToken public s_winningToken;\n    bool public s_isReported;\n\n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n\n    event TokensPurchased(address indexed buyer, Outcome outcome, uint256 amount, uint256 ttrustAmount);\n    event TokensSold(address indexed seller, Outcome outcome, uint256 amount, uint256 ttrustAmount);\n    event WinningTokensRedeemed(address indexed redeemer, uint256 amount, uint256 ttrustAmount);\n    event MarketReported(address indexed oracle, Outcome winningOutcome, address winningToken);\n    event MarketResolved(address indexed resolver, uint256 totalTTrustToSend);\n    event LiquidityAdded(address indexed provider, uint256 ttrustAmount, uint256 tokensAmount);\n    event LiquidityRemoved(address indexed provider, uint256 ttrustAmount, uint256 tokensAmount);\n\n    /////////////////\n    /// Modifiers ///\n    /////////////////\n\n    /// Checkpoint 5 ///\n    modifier predictionNotReported() {\n        if (s_isReported) {\n            revert PredictionMarketTTrust__PredictionAlreadyReported();\n        }\n        _;\n    }\n\n    /// Checkpoint 6 ///\n    modifier predictionReported() {\n        if (!s_isReported) {\n            revert PredictionMarketTTrust__PredictionNotReported();\n        }\n        _;\n    }\n\n    /// Checkpoint 8 ///\n    modifier notOwner() {\n        if (msg.sender == owner()) {\n            revert PredictionMarketTTrust__OwnerCannotCall();\n        }\n        _;\n    }\n\n    modifier amountGreaterThanZero(uint256 _amount) {\n        if (_amount == 0) {\n            revert PredictionMarketTTrust__AmountMustBeGreaterThanZero();\n        }\n        _;\n    }\n\n    //////////////////\n    ////Constructor///\n    //////////////////\n\n    constructor(\n        address _liquidityProvider,\n        address _oracle,\n        address _ttrustToken,\n        string memory _question,\n        uint256 _initialTokenValue,\n        uint8 _initialYesProbability,\n        uint8 _percentageToLock,\n        uint256 _initialTTrustLiquidity\n    ) Ownable(_liquidityProvider) {\n        /// Checkpoint 2 ////\n        if (_initialTTrustLiquidity == 0) {\n            revert PredictionMarketTTrust__MustProvideTTrustForInitialLiquidity();\n        }\n        if (_initialYesProbability >= 100 || _initialYesProbability == 0) {\n            revert PredictionMarketTTrust__InvalidProbability();\n        }\n        if (_percentageToLock >= 100 || _percentageToLock == 0) {\n            revert PredictionMarketTTrust__InvalidPercentageToLock();\n        }\n\n        i_ttrustToken = IERC20(_ttrustToken);\n        i_oracle = _oracle;\n        s_question = _question;\n        i_initialTokenValue = _initialTokenValue;\n        i_initialYesProbability = _initialYesProbability;\n        i_percentageLocked = _percentageToLock;\n\n        // Transfer initial TTrust liquidity from deployer\n        bool success = i_ttrustToken.transferFrom(_liquidityProvider, address(this), _initialTTrustLiquidity);\n        if (!success) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        s_ttrustCollateral = _initialTTrustLiquidity;\n\n        /// Checkpoint 3 ////\n        uint256 initialTokenAmount = (_initialTTrustLiquidity * PRECISION) / _initialTokenValue;\n        i_yesToken = new PredictionMarketToken(\"Yes\", \"Y\", msg.sender, initialTokenAmount);\n        i_noToken = new PredictionMarketToken(\"No\", \"N\", msg.sender, initialTokenAmount);\n\n        uint256 initialYesAmountLocked = (initialTokenAmount * _initialYesProbability * _percentageToLock * 2) / 10000;\n        uint256 initialNoAmountLocked = (initialTokenAmount * (100 - _initialYesProbability) * _percentageToLock * 2) / 10000;\n\n        bool success1 = i_yesToken.transfer(msg.sender, initialYesAmountLocked);\n        bool success2 = i_noToken.transfer(msg.sender, initialNoAmountLocked);\n        if (!success1 || !success2) {\n            revert PredictionMarketTTrust__TokenTransferFailed();\n        }\n    }\n\n    /////////////////\n    /// Functions ///\n    /////////////////\n\n    /**\n     * @notice Add liquidity to the prediction market with TTrust\n     * @dev Only the owner can add liquidity and only if the prediction is not reported\n     * @param _ttrustAmount Amount of TTrust to add as liquidity\n     */\n    function addLiquidity(uint256 _ttrustAmount) external onlyOwner predictionNotReported {\n        //// Checkpoint 4 ////\n        bool success = i_ttrustToken.transferFrom(msg.sender, address(this), _ttrustAmount);\n        if (!success) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        s_ttrustCollateral += _ttrustAmount;\n\n        uint256 tokensAmount = (_ttrustAmount * PRECISION) / i_initialTokenValue;\n\n        i_yesToken.mint(address(this), tokensAmount);\n        i_noToken.mint(address(this), tokensAmount);\n\n        emit LiquidityAdded(msg.sender, _ttrustAmount, tokensAmount);\n    }\n\n    /**\n     * @notice Remove liquidity from the prediction market\n     * @param _ttrustToWithdraw Amount of TTrust to withdraw from liquidity pool\n     */\n    function removeLiquidity(uint256 _ttrustToWithdraw) external onlyOwner predictionNotReported {\n        //// Checkpoint 4 ////\n        uint256 amountTokenToBurn = (_ttrustToWithdraw / i_initialTokenValue) * PRECISION;\n\n        if (amountTokenToBurn > (i_yesToken.balanceOf(address(this)))) {\n            revert PredictionMarketTTrust__InsufficientTokenReserve(Outcome.YES, amountTokenToBurn);\n        }\n        if (amountTokenToBurn > (i_noToken.balanceOf(address(this)))) {\n            revert PredictionMarketTTrust__InsufficientTokenReserve(Outcome.NO, amountTokenToBurn);\n        }\n\n        s_ttrustCollateral -= _ttrustToWithdraw;\n\n        i_yesToken.burn(address(this), amountTokenToBurn);\n        i_noToken.burn(address(this), amountTokenToBurn);\n\n        bool success = i_ttrustToken.transfer(msg.sender, _ttrustToWithdraw);\n        if (!success) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        emit LiquidityRemoved(msg.sender, _ttrustToWithdraw, amountTokenToBurn);\n    }\n\n    /**\n     * @notice Report the winning outcome for the prediction\n     */\n    function report(Outcome _winningOutcome) external predictionNotReported {\n        //// Checkpoint 5 ////\n        if (msg.sender != i_oracle) {\n            revert PredictionMarketTTrust__OnlyOracleCanReport();\n        }\n        s_winningToken = _winningOutcome == Outcome.YES ? i_yesToken : i_noToken;\n        s_isReported = true;\n        emit MarketReported(msg.sender, _winningOutcome, address(s_winningToken));\n    }\n\n    /**\n     * @notice Owner can withdraw profits after resolution\n     */\n    function resolveMarketAndWithdraw() external onlyOwner predictionReported returns (uint256 ttrustRedeemed) {\n        /// Checkpoint 6 ////\n        uint256 contractWinningTokens = s_winningToken.balanceOf(address(this));\n        if (contractWinningTokens > 0) {\n            ttrustRedeemed = (contractWinningTokens * i_initialTokenValue) / PRECISION;\n\n            if (ttrustRedeemed > s_ttrustCollateral) {\n                ttrustRedeemed = s_ttrustCollateral;\n            }\n\n            s_ttrustCollateral -= ttrustRedeemed;\n        }\n\n        uint256 totalTTrustToSend = ttrustRedeemed + s_lpTradingRevenue;\n        s_lpTradingRevenue = 0;\n\n        s_winningToken.burn(address(this), contractWinningTokens);\n\n        bool success = i_ttrustToken.transfer(msg.sender, totalTTrustToSend);\n        if (!success) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        emit MarketResolved(msg.sender, totalTTrustToSend);\n        return ttrustRedeemed;\n    }\n\n    /**\n     * @notice Buy prediction tokens with TTrust\n     */\n    function buyTokensWithTTrust(Outcome _outcome, uint256 _amountTokenToBuy) \n        external \n        amountGreaterThanZero(_amountTokenToBuy)\n        predictionNotReported\n        notOwner\n    {\n        /// Checkpoint 8 ////\n        uint256 ttrustNeeded = getBuyPriceInTTrust(_outcome, _amountTokenToBuy);\n        \n        // Check allowance and balance\n        uint256 allowance = i_ttrustToken.allowance(msg.sender, address(this));\n        if (allowance < ttrustNeeded) {\n            revert PredictionMarketTTrust__InsufficientTTrustAllowance();\n        }\n\n        uint256 balance = i_ttrustToken.balanceOf(msg.sender);\n        if (balance < ttrustNeeded) {\n            revert PredictionMarketTTrust__InsufficientBalance(ttrustNeeded, balance);\n        }\n\n        PredictionMarketToken optionToken = _outcome == Outcome.YES ? i_yesToken : i_noToken;\n\n        if (_amountTokenToBuy > optionToken.balanceOf(address(this))) {\n            revert PredictionMarketTTrust__InsufficientTokenReserve(_outcome, _amountTokenToBuy);\n        }\n\n        // Transfer TTrust from user\n        bool success1 = i_ttrustToken.transferFrom(msg.sender, address(this), ttrustNeeded);\n        if (!success1) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        s_lpTradingRevenue += ttrustNeeded;\n\n        bool success2 = optionToken.transfer(msg.sender, _amountTokenToBuy);\n        if (!success2) {\n            revert PredictionMarketTTrust__TokenTransferFailed();\n        }\n\n        emit TokensPurchased(msg.sender, _outcome, _amountTokenToBuy, ttrustNeeded);\n    }\n\n    /**\n     * @notice Sell prediction tokens for TTrust\n     */\n    function sellTokensForTTrust(Outcome _outcome, uint256 _tradingAmount)\n        external\n        amountGreaterThanZero(_tradingAmount)\n        predictionNotReported\n        notOwner\n    {\n        /// Checkpoint 8 ////\n        PredictionMarketToken optionToken = _outcome == Outcome.YES ? i_yesToken : i_noToken;\n        uint256 userBalance = optionToken.balanceOf(msg.sender);\n        if (userBalance < _tradingAmount) {\n            revert PredictionMarketTTrust__InsufficientBalance(_tradingAmount, userBalance);\n        }\n\n        uint256 allowance = optionToken.allowance(msg.sender, address(this));\n        if (allowance < _tradingAmount) {\n            revert PredictionMarketTTrust__InsufficientAllowance(_tradingAmount, allowance);\n        }\n\n        uint256 ttrustToReceive = getSellPriceInTTrust(_outcome, _tradingAmount);\n\n        s_lpTradingRevenue -= ttrustToReceive;\n\n        bool success1 = i_ttrustToken.transfer(msg.sender, ttrustToReceive);\n        if (!success1) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        bool success2 = optionToken.transferFrom(msg.sender, address(this), _tradingAmount);\n        if (!success2) {\n            revert PredictionMarketTTrust__TokenTransferFailed();\n        }\n\n        emit TokensSold(msg.sender, _outcome, _tradingAmount, ttrustToReceive);\n    }\n\n    /**\n     * @notice Redeem winning tokens for TTrust\n     */\n    function redeemWinningTokens(uint256 _amount) external amountGreaterThanZero(_amount) predictionReported notOwner {\n        /// Checkpoint 9 ////\n        if (s_winningToken.balanceOf(msg.sender) < _amount) {\n            revert PredictionMarketTTrust__InsufficientWinningTokens();\n        }\n\n        uint256 ttrustToReceive = (_amount * i_initialTokenValue) / PRECISION;\n        s_ttrustCollateral -= ttrustToReceive;\n\n        s_winningToken.burn(msg.sender, _amount);\n\n        bool success = i_ttrustToken.transfer(msg.sender, ttrustToReceive);\n        if (!success) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        emit WinningTokensRedeemed(msg.sender, _amount, ttrustToReceive);\n    }\n\n    /**\n     * @notice Calculate TTrust price for buying tokens\n     */\n    function getBuyPriceInTTrust(Outcome _outcome, uint256 _tradingAmount) public view returns (uint256) {\n        /// Checkpoint 7 ////\n        return _calculatePriceInTTrust(_outcome, _tradingAmount, false);\n    }\n\n    /**\n     * @notice Calculate TTrust price for selling tokens\n     */\n    function getSellPriceInTTrust(Outcome _outcome, uint256 _tradingAmount) public view returns (uint256) {\n        /// Checkpoint 7 ////\n        return _calculatePriceInTTrust(_outcome, _tradingAmount, true);\n    }\n\n    /////////////////////////\n    /// Helper Functions ///\n    ////////////////////////\n\n    /**\n     * @dev Internal helper to calculate TTrust price for both buying and selling\n     */\n    function _calculatePriceInTTrust(\n        Outcome _outcome,\n        uint256 _tradingAmount,\n        bool _isSelling\n    ) private view returns (uint256) {\n        /// Checkpoint 7 ////\n        (uint256 currentTokenReserve, uint256 currentOtherTokenReserve) = _getCurrentReserves(_outcome);\n\n        /// Ensure sufficient liquidity when buying\n        if (!_isSelling) {\n            if (currentTokenReserve < _tradingAmount) {\n                revert PredictionMarketTTrust__InsufficientLiquidity();\n            }\n        }\n\n        uint256 totalTokenSupply = i_yesToken.totalSupply();\n\n        /// Before trade\n        uint256 currentTokenSoldBefore = totalTokenSupply - currentTokenReserve;\n        uint256 currentOtherTokenSold = totalTokenSupply - currentOtherTokenReserve;\n\n        uint256 totalTokensSoldBefore = currentTokenSoldBefore + currentOtherTokenSold;\n        uint256 probabilityBefore = _calculateProbability(currentTokenSoldBefore, totalTokensSoldBefore);\n\n        /// After trade\n        uint256 currentTokenReserveAfter =\n            _isSelling ? currentTokenReserve + _tradingAmount : currentTokenReserve - _tradingAmount;\n        uint256 currentTokenSoldAfter = totalTokenSupply - currentTokenReserveAfter;\n\n        uint256 totalTokensSoldAfter =\n            _isSelling ? totalTokensSoldBefore - _tradingAmount : totalTokensSoldBefore + _tradingAmount;\n\n        uint256 probabilityAfter = _calculateProbability(currentTokenSoldAfter, totalTokensSoldAfter);\n\n        /// Compute final price\n        uint256 probabilityAvg = (probabilityBefore + probabilityAfter) / 2;\n        return (i_initialTokenValue * probabilityAvg * _tradingAmount) / (PRECISION * PRECISION);\n    }\n\n    function _getCurrentReserves(Outcome _outcome) private view returns (uint256, uint256) {\n        if (_outcome == Outcome.YES) {\n            return (i_yesToken.balanceOf(address(this)), i_noToken.balanceOf(address(this)));\n        } else {\n            return (i_noToken.balanceOf(address(this)), i_yesToken.balanceOf(address(this)));\n        }\n    }\n\n    function _calculateProbability(uint256 tokensSold, uint256 totalSold) private pure returns (uint256) {\n        return (tokensSold * PRECISION) / totalSold;\n    }\n\n    /////////////////////////\n    /// Getter Functions ///\n    ////////////////////////\n\n    /**\n     * @notice Get the prediction details\n     */\n    function getPrediction()\n        external\n        view\n        returns (\n            string memory question,\n            string memory outcome1,\n            string memory outcome2,\n            address oracle,\n            uint256 initialTokenValue,\n            uint256 yesTokenReserve,\n            uint256 noTokenReserve,\n            bool isReported,\n            address yesToken,\n            address noToken,\n            address winningToken,\n            uint256 ttrustCollateral,\n            uint256 lpTradingRevenue,\n            address predictionMarketOwner,\n            uint256 initialProbability,\n            uint256 percentageLocked,\n            address ttrustToken\n        )\n    {\n        oracle = i_oracle;\n        initialTokenValue = i_initialTokenValue;\n        percentageLocked = i_percentageLocked;\n        initialProbability = i_initialYesProbability;\n        question = s_question;\n        ttrustCollateral = s_ttrustCollateral;\n        lpTradingRevenue = s_lpTradingRevenue;\n        predictionMarketOwner = owner();\n        yesToken = address(i_yesToken);\n        noToken = address(i_noToken);\n        outcome1 = i_yesToken.name();\n        outcome2 = i_noToken.name();\n        yesTokenReserve = i_yesToken.balanceOf(address(this));\n        noTokenReserve = i_noToken.balanceOf(address(this));\n        isReported = s_isReported;\n        winningToken = address(s_winningToken);\n        ttrustToken = address(i_ttrustToken);\n    }\n}"
    },
    "contracts/TTrustMarketCapPredictionTTrust.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { PredictionMarketTTrust } from \"./PredictionMarketTTrust.sol\";\nimport { TTrustPriceOracle } from \"./TTrustPriceOracle.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TTrustMarketCapPredictionTTrust\n * @notice Prediction market for TTrust token predictions using TTrust as currency\n * @dev Extends functionality with TTrust-specific logic and uses TTrust token for all transactions\n */\ncontract TTrustMarketCapPredictionTTrust is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error TTrustMarketCapPredictionTTrust__MarketNotResolved();\n    error TTrustMarketCapPredictionTTrust__MarketAlreadyResolved();\n    error TTrustMarketCapPredictionTTrust__DeadlinePassed();\n    error TTrustMarketCapPredictionTTrust__DeadlineNotReached();\n    error TTrustMarketCapPredictionTTrust__InvalidTargetValue();\n    error TTrustMarketCapPredictionTTrust__OracleDataStale();\n    error TTrustMarketCapPredictionTTrust__InvalidPredictionType();\n\n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n\n    enum PredictionType {\n        MARKET_CAP_ABOVE,     // Market cap will be above target\n        MARKET_CAP_BELOW,     // Market cap will be below target\n        PRICE_ABOVE,          // Price will be above target\n        PRICE_BELOW           // Price will be below target\n    }\n\n    struct PredictionDetails {\n        PredictionType predictionType;\n        uint256 targetValue;        // Target market cap or price (18 decimals)\n        uint256 deadline;           // When prediction expires\n        string description;         // Human readable description\n        bool isResolved;           // Has this prediction been resolved\n        bool targetReached;        // Did target get reached\n        uint256 resolutionValue;   // Actual value at resolution time\n        uint256 resolutionTime;    // When it was resolved\n    }\n\n    // Core prediction market contract (handles token trading with TTrust)\n    PredictionMarketTTrust public immutable predictionMarket;\n\n    // Oracle for TTrust price/market cap data\n    TTrustPriceOracle public immutable priceOracle;\n\n    // TTrust token contract\n    IERC20 public immutable ttrustToken;\n\n    // Prediction details\n    PredictionDetails public prediction;\n\n    uint256 public constant PRECISION = 1e18;\n    uint256 public constant RESOLUTION_BUFFER = 1 hours; // Grace period after deadline\n\n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n\n    event PredictionCreated(\n        PredictionType indexed predictionType,\n        uint256 indexed targetValue,\n        uint256 indexed deadline,\n        string description\n    );\n\n    event PredictionResolved(\n        bool indexed targetReached,\n        uint256 actualValue,\n        uint256 targetValue,\n        uint256 resolutionTime\n    );\n\n    event EmergencyResolution(\n        bool targetReached,\n        string reason\n    );\n\n    /////////////////\n    /// Modifiers ///\n    /////////////////\n\n    modifier beforeDeadline() {\n        if (block.timestamp >= prediction.deadline) {\n            revert TTrustMarketCapPredictionTTrust__DeadlinePassed();\n        }\n        _;\n    }\n\n    modifier afterDeadline() {\n        if (block.timestamp < prediction.deadline + RESOLUTION_BUFFER) {\n            revert TTrustMarketCapPredictionTTrust__DeadlineNotReached();\n        }\n        _;\n    }\n\n    modifier notResolved() {\n        if (prediction.isResolved) {\n            revert TTrustMarketCapPredictionTTrust__MarketAlreadyResolved();\n        }\n        _;\n    }\n\n    modifier resolved() {\n        if (!prediction.isResolved) {\n            revert TTrustMarketCapPredictionTTrust__MarketNotResolved();\n        }\n        _;\n    }\n\n    //////////////////\n    ////Constructor///\n    //////////////////\n\n    constructor(\n        address _liquidityProvider,\n        address _priceOracle,\n        address _ttrustToken,\n        PredictionType _predictionType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _initialTokenValue,\n        uint8 _initialYesProbability,\n        uint8 _percentageToLock,\n        uint256 _initialTTrustLiquidity\n    ) Ownable(_liquidityProvider) {\n        \n        if (_targetValue == 0) {\n            revert TTrustMarketCapPredictionTTrust__InvalidTargetValue();\n        }\n\n        if (_deadline <= block.timestamp) {\n            revert TTrustMarketCapPredictionTTrust__DeadlinePassed();\n        }\n\n        // Set oracle and TTrust token\n        priceOracle = TTrustPriceOracle(_priceOracle);\n        ttrustToken = IERC20(_ttrustToken);\n\n        // Store prediction details\n        prediction = PredictionDetails({\n            predictionType: _predictionType,\n            targetValue: _targetValue,\n            deadline: _deadline,\n            description: _description,\n            isResolved: false,\n            targetReached: false,\n            resolutionValue: 0,\n            resolutionTime: 0\n        });\n\n        // Create underlying prediction market with TTrust\n        string memory question = _buildQuestionString(_predictionType, _targetValue, _deadline, _description);\n\n        predictionMarket = new PredictionMarketTTrust(\n            _liquidityProvider,\n            address(this), // This contract acts as oracle\n            _ttrustToken,\n            question,\n            _initialTokenValue,\n            _initialYesProbability,\n            _percentageToLock,\n            _initialTTrustLiquidity\n        );\n\n        emit PredictionCreated(_predictionType, _targetValue, _deadline, _description);\n    }\n\n    /////////////////\n    /// Functions ///\n    /////////////////\n\n    /**\n     * @notice Buy prediction tokens with TTrust (YES = target will be reached, NO = target won't be reached)\n     */\n    function buyTokens(PredictionMarketTTrust.Outcome _outcome, uint256 _amountTokenToBuy) \n        external \n        beforeDeadline\n        notResolved\n    {\n        predictionMarket.buyTokensWithTTrust(_outcome, _amountTokenToBuy);\n    }\n\n    /**\n     * @notice Sell prediction tokens for TTrust\n     */\n    function sellTokens(PredictionMarketTTrust.Outcome _outcome, uint256 _tradingAmount)\n        external\n        beforeDeadline\n        notResolved\n    {\n        predictionMarket.sellTokensForTTrust(_outcome, _tradingAmount);\n    }\n\n    /**\n     * @notice Resolve the prediction by checking current TTrust data\n     */\n    function resolvePrediction() external afterDeadline notResolved {\n        \n        // Get current data from oracle\n        (uint256 currentValue, uint256 timestamp) = _getCurrentValue();\n\n        // Check if oracle data is fresh enough\n        if (block.timestamp - timestamp > 2 hours) {\n            revert TTrustMarketCapPredictionTTrust__OracleDataStale();\n        }\n\n        // Determine if target was reached\n        bool targetReached = _evaluateTarget(currentValue);\n\n        // Update prediction state\n        prediction.isResolved = true;\n        prediction.targetReached = targetReached;\n        prediction.resolutionValue = currentValue;\n        prediction.resolutionTime = block.timestamp;\n\n        // Report to underlying prediction market\n        PredictionMarketTTrust.Outcome winningOutcome = targetReached ? \n            PredictionMarketTTrust.Outcome.YES : \n            PredictionMarketTTrust.Outcome.NO;\n            \n        predictionMarket.report(winningOutcome);\n\n        emit PredictionResolved(targetReached, currentValue, prediction.targetValue, block.timestamp);\n    }\n\n    /**\n     * @notice Emergency resolution by owner (in case of oracle issues)\n     */\n    function emergencyResolve(bool _targetReached, string memory _reason) \n        external \n        onlyOwner \n        notResolved \n    {\n        prediction.isResolved = true;\n        prediction.targetReached = _targetReached;\n        prediction.resolutionTime = block.timestamp;\n\n        PredictionMarketTTrust.Outcome winningOutcome = _targetReached ? \n            PredictionMarketTTrust.Outcome.YES : \n            PredictionMarketTTrust.Outcome.NO;\n            \n        predictionMarket.report(winningOutcome);\n\n        emit EmergencyResolution(_targetReached, _reason);\n    }\n\n    /**\n     * @notice Redeem winning tokens after resolution\n     */\n    function redeemWinningTokens(uint256 _amount) external resolved {\n        predictionMarket.redeemWinningTokens(_amount);\n    }\n\n    /**\n     * @notice Owner can withdraw profits after resolution\n     */\n    function withdrawProfits() external onlyOwner resolved {\n        predictionMarket.resolveMarketAndWithdraw();\n    }\n\n    /////////////////////////\n    /// Internal Functions //\n    /////////////////////////\n\n    /**\n     * @dev Get current value based on prediction type\n     */\n    function _getCurrentValue() internal view returns (uint256 value, uint256 timestamp) {\n        if (prediction.predictionType == PredictionType.MARKET_CAP_ABOVE || \n            prediction.predictionType == PredictionType.MARKET_CAP_BELOW) {\n            return priceOracle.getMarketCap();\n        } else {\n            return priceOracle.getPrice();\n        }\n    }\n\n    /**\n     * @dev Evaluate if target was reached based on prediction type\n     */\n    function _evaluateTarget(uint256 currentValue) internal view returns (bool) {\n        if (prediction.predictionType == PredictionType.MARKET_CAP_ABOVE || \n            prediction.predictionType == PredictionType.PRICE_ABOVE) {\n            return currentValue >= prediction.targetValue;\n        } else {\n            return currentValue <= prediction.targetValue;\n        }\n    }\n\n    /**\n     * @dev Build human-readable question string\n     */\n    function _buildQuestionString(\n        PredictionType _type,\n        uint256 _target,\n        uint256 _deadline,\n        string memory _description\n    ) internal pure returns (string memory) {\n        // This is a simplified version - in production you'd format the numbers properly\n        if (_type == PredictionType.MARKET_CAP_ABOVE) {\n            return string(abi.encodePacked(\"Will TTrust market cap exceed target by deadline? \", _description));\n        } else if (_type == PredictionType.MARKET_CAP_BELOW) {\n            return string(abi.encodePacked(\"Will TTrust market cap stay below target by deadline? \", _description));\n        } else if (_type == PredictionType.PRICE_ABOVE) {\n            return string(abi.encodePacked(\"Will TTrust price exceed target by deadline? \", _description));\n        } else {\n            return string(abi.encodePacked(\"Will TTrust price stay below target by deadline? \", _description));\n        }\n    }\n\n    /////////////////////////\n    /// View Functions //////\n    /////////////////////////\n\n    /**\n     * @notice Get current TTrust metrics for display\n     */\n    function getCurrentTTrustData() \n        external \n        view \n        returns (\n            uint256 currentPrice,\n            uint256 currentMarketCap,\n            uint256 lastUpdate,\n            bool isStale\n        ) \n    {\n        try priceOracle.getPrice() returns (uint256 price, uint256 timestamp) {\n            currentPrice = price;\n            lastUpdate = timestamp;\n            \n            try priceOracle.getMarketCap() returns (uint256 marketCap, uint256 mcTimestamp) {\n                currentMarketCap = marketCap;\n                if (mcTimestamp > lastUpdate) lastUpdate = mcTimestamp;\n            } catch {\n                currentMarketCap = 0;\n            }\n            \n            isStale = (block.timestamp - lastUpdate) > 2 hours;\n        } catch {\n            currentPrice = 0;\n            currentMarketCap = 0;\n            lastUpdate = 0;\n            isStale = true;\n        }\n    }\n\n    /**\n     * @notice Get complete prediction information\n     */\n    function getPredictionInfo()\n        external\n        view\n        returns (\n            PredictionType predictionType,\n            uint256 targetValue,\n            uint256 deadline,\n            string memory description,\n            bool isResolved,\n            bool targetReached,\n            uint256 resolutionValue,\n            uint256 resolutionTime,\n            address predictionMarketAddress\n        )\n    {\n        return (\n            prediction.predictionType,\n            prediction.targetValue,\n            prediction.deadline,\n            prediction.description,\n            prediction.isResolved,\n            prediction.targetReached,\n            prediction.resolutionValue,\n            prediction.resolutionTime,\n            address(predictionMarket)\n        );\n    }\n\n    /**\n     * @notice Get trading information from underlying market\n     */\n    function getTradingInfo()\n        external\n        view\n        returns (\n            uint256 yesTokenPrice,\n            uint256 noTokenPrice,\n            uint256 yesTokenReserve,\n            uint256 noTokenReserve,\n            address yesToken,\n            address noToken\n        )\n    {\n        yesTokenPrice = predictionMarket.getBuyPriceInTTrust(PredictionMarketTTrust.Outcome.YES, 1 ether);\n        noTokenPrice = predictionMarket.getBuyPriceInTTrust(PredictionMarketTTrust.Outcome.NO, 1 ether);\n        \n        (,,,, ,yesTokenReserve, noTokenReserve, , yesToken, noToken, , , , , , , ) = predictionMarket.getPrediction();\n    }\n\n    /**\n     * @notice Check if prediction can be resolved\n     */\n    function canResolve() external view returns (bool) {\n        return !prediction.isResolved && \n               block.timestamp >= prediction.deadline + RESOLUTION_BUFFER &&\n               priceOracle.isPriceValid();\n    }\n\n    /**\n     * @notice Get time left until deadline\n     */\n    function getTimeToDeadline() external view returns (uint256) {\n        if (block.timestamp >= prediction.deadline) {\n            return 0;\n        }\n        return prediction.deadline - block.timestamp;\n    }\n}"
    },
    "contracts/TTrustPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { AggregatorV3Interface } from \"./interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title TTrustPriceOracle\n * @notice Oracle contract to get TTrust price data from multiple sources\n * @dev Can integrate with DEX prices, external oracles, or manual price feeds\n */\ncontract TTrustPriceOracle is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error TTrustPriceOracle__PriceStale();\n    error TTrustPriceOracle__InvalidPrice();\n    error TTrustPriceOracle__OnlyTrustedUpdater();\n    error TTrustPriceOracle__InvalidDEXAddress();\n    \n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n    \n    struct PriceData {\n        uint256 price;          // Price in USD (18 decimals)\n        uint256 timestamp;      // Last update timestamp\n        uint256 marketCap;      // Market cap in USD (18 decimals)\n        bool isValid;           // Is this price valid\n    }\n    \n    PriceData public currentPrice;\n    \n    uint256 public constant PRICE_STALENESS_THRESHOLD = 1 hours;\n    uint256 public constant PRECISION = 1e18;\n    \n    // Trusted price updaters (can be set to external oracles or bots)\n    mapping(address => bool) public trustedUpdaters;\n    \n    // DEX contract address for getting prices from liquidity pools\n    address public dexRouter;\n    address public ttustIntuitPair;\n    \n    // Backup price feeds (Chainlink style)\n    AggregatorV3Interface public backupPriceFeed;\n    \n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n    \n    event PriceUpdated(uint256 indexed price, uint256 indexed marketCap, uint256 timestamp, address updater);\n    event TrustedUpdaterSet(address indexed updater, bool trusted);\n    event DEXRouterSet(address indexed router, address indexed pair);\n    event BackupPriceFeedSet(address indexed priceFeed);\n    \n    /////////////////\n    /// Modifiers ///\n    /////////////////\n    \n    modifier onlyTrustedUpdater() {\n        if (!trustedUpdaters[msg.sender] && msg.sender != owner()) {\n            revert TTrustPriceOracle__OnlyTrustedUpdater();\n        }\n        _;\n    }\n    \n    //////////////////\n    ////Constructor///\n    //////////////////\n    \n    constructor(\n        address _owner,\n        uint256 _initialPrice,\n        uint256 _initialMarketCap\n    ) Ownable(_owner) {\n        // Set initial price data\n        currentPrice = PriceData({\n            price: _initialPrice,\n            timestamp: block.timestamp,\n            marketCap: _initialMarketCap,\n            isValid: true\n        });\n        \n        // Owner is automatically a trusted updater\n        trustedUpdaters[_owner] = true;\n        \n        emit PriceUpdated(_initialPrice, _initialMarketCap, block.timestamp, msg.sender);\n    }\n    \n    /////////////////\n    /// Functions ///\n    /////////////////\n    \n    /**\n     * @notice Update TTrust price manually (for trusted updaters)\n     * @param _price New price in USD (18 decimals)\n     * @param _marketCap New market cap in USD (18 decimals)\n     */\n    function updatePrice(uint256 _price, uint256 _marketCap) \n        external \n        onlyTrustedUpdater \n    {\n        if (_price == 0) {\n            revert TTrustPriceOracle__InvalidPrice();\n        }\n        \n        currentPrice = PriceData({\n            price: _price,\n            timestamp: block.timestamp,\n            marketCap: _marketCap,\n            isValid: true\n        });\n        \n        emit PriceUpdated(_price, _marketCap, block.timestamp, msg.sender);\n    }\n    \n    /**\n     * @notice Get current TTrust price\n     * @return price Current price in USD (18 decimals)\n     * @return timestamp Last update timestamp\n     */\n    function getPrice() external view returns (uint256 price, uint256 timestamp) {\n        if (!isPriceValid()) {\n            revert TTrustPriceOracle__PriceStale();\n        }\n        \n        return (currentPrice.price, currentPrice.timestamp);\n    }\n    \n    /**\n     * @notice Get current TTrust market cap\n     * @return marketCap Current market cap in USD (18 decimals)\n     * @return timestamp Last update timestamp\n     */\n    function getMarketCap() external view returns (uint256 marketCap, uint256 timestamp) {\n        if (!isPriceValid()) {\n            revert TTrustPriceOracle__PriceStale();\n        }\n        \n        return (currentPrice.marketCap, currentPrice.timestamp);\n    }\n    \n    /**\n     * @notice Check if current price is valid (not stale)\n     * @return bool True if price is valid\n     */\n    function isPriceValid() public view returns (bool) {\n        return currentPrice.isValid && \n               (block.timestamp - currentPrice.timestamp) <= PRICE_STALENESS_THRESHOLD;\n    }\n    \n    /**\n     * @notice Get price from DEX (if configured)\n     * @return price Price from DEX\n     */\n    function getPriceFromDEX() external view returns (uint256 price) {\n        // This would integrate with the existing DEX to get TTrust price\n        // Implementation depends on the DEX structure\n        if (dexRouter == address(0)) {\n            return 0;\n        }\n        \n        // TODO: Implement actual DEX price fetching\n        // For now, return current price as fallback\n        return currentPrice.price;\n    }\n    \n    /////////////////////////\n    /// Admin Functions ////\n    /////////////////////////\n    \n    /**\n     * @notice Set trusted updater status\n     * @param _updater Address to set trust status for\n     * @param _trusted Whether this address is trusted\n     */\n    function setTrustedUpdater(address _updater, bool _trusted) external onlyOwner {\n        trustedUpdaters[_updater] = _trusted;\n        emit TrustedUpdaterSet(_updater, _trusted);\n    }\n    \n    /**\n     * @notice Set DEX router and pair addresses for price fetching\n     * @param _router DEX router address\n     * @param _pair TTrust/INTUIT pair address\n     */\n    function setDEXAddresses(address _router, address _pair) external onlyOwner {\n        if (_router == address(0) || _pair == address(0)) {\n            revert TTrustPriceOracle__InvalidDEXAddress();\n        }\n        \n        dexRouter = _router;\n        ttustIntuitPair = _pair;\n        \n        emit DEXRouterSet(_router, _pair);\n    }\n    \n    /**\n     * @notice Set backup price feed (Chainlink style)\n     * @param _priceFeed Chainlink price feed address\n     */\n    function setBackupPriceFeed(address _priceFeed) external onlyOwner {\n        backupPriceFeed = AggregatorV3Interface(_priceFeed);\n        emit BackupPriceFeedSet(_priceFeed);\n    }\n    \n    /**\n     * @notice Emergency function to invalidate current price\n     */\n    function invalidatePrice() external onlyOwner {\n        currentPrice.isValid = false;\n    }\n    \n    /////////////////////////\n    /// Getter Functions ///\n    /////////////////////////\n    \n    /**\n     * @notice Get all price data\n     */\n    function getAllPriceData() \n        external \n        view \n        returns (\n            uint256 price,\n            uint256 timestamp,\n            uint256 marketCap,\n            bool isValid,\n            bool isStale\n        ) \n    {\n        price = currentPrice.price;\n        timestamp = currentPrice.timestamp;\n        marketCap = currentPrice.marketCap;\n        isValid = currentPrice.isValid;\n        isStale = !isPriceValid();\n    }\n}"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}