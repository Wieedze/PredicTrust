{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    "contracts/PredictionFactoryNative.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { SimpleNativeMarket } from \"./SimpleNativeMarket.sol\";\nimport { TTrustPriceOracle } from \"./TTrustPriceOracle.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title PredictionFactoryNative\n * @notice Factory contract for creating TTrust-based prediction markets using native TTRUST token\n */\ncontract PredictionFactoryNative is Ownable {\n    \n    enum PredictionType {\n        MARKET_CAP_ABOVE,\n        MARKET_CAP_BELOW,\n        PRICE_ABOVE,\n        PRICE_BELOW\n    }\n    \n    // Oracle\n    TTrustPriceOracle public ttustPriceOracle;\n    \n    // Market registry\n    address[] public allMarkets;\n    uint256 public marketCount;\n    \n    // Settings (in native TTRUST wei)\n    uint256 public minimumLiquidity = 1e17; // 0.1 TTRUST minimum\n    uint256 public creationFee = 1e15; // 0.001 TTRUST creation fee\n    \n    event TTrustMarketCreated(\n        address indexed marketAddress,\n        address indexed creator,\n        PredictionType indexed predictionType,\n        uint256 targetValue,\n        uint256 deadline,\n        string title,\n        string question\n    );\n    \n    modifier validLiquidity(uint256 _liquidity) {\n        require(_liquidity >= minimumLiquidity, \"Insufficient liquidity\");\n        _;\n    }\n    \n    modifier validDeadline(uint256 _deadline) {\n        require(_deadline > block.timestamp, \"Invalid deadline\");\n        _;\n    }\n    \n    constructor(\n        address _owner,\n        address _ttustPriceOracle\n    ) Ownable(_owner) {\n        if (_ttustPriceOracle != address(0)) {\n            ttustPriceOracle = TTrustPriceOracle(_ttustPriceOracle);\n        }\n    }\n    \n    /**\n     * @notice Create a new TTrust prediction market using native TTRUST\n     */\n    function createTTrustMarket(\n        PredictionType _predictionType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _title,\n        string memory _predictionQuestion\n    )\n        external\n        payable\n        validLiquidity(msg.value)\n        validDeadline(_deadline)\n        returns (address marketAddress)\n    {\n        require(address(ttustPriceOracle) != address(0), \"Oracle not set\");\n        require(_targetValue > 0, \"Invalid target value\");\n        require(msg.value >= minimumLiquidity + creationFee, \"Insufficient TTRUST sent\");\n        \n        // Calculate actual liquidity (subtract creation fee)\n        uint256 actualLiquidity = msg.value - creationFee;\n        \n        // Create the market with native TTRUST\n        SimpleNativeMarket.PredictionType marketPredictionType = SimpleNativeMarket.PredictionType(uint8(_predictionType));\n        \n        SimpleNativeMarket market = new SimpleNativeMarket{value: actualLiquidity}(\n            msg.sender,\n            marketPredictionType,\n            _targetValue,\n            _deadline,\n            _title,\n            _predictionQuestion\n        );\n        \n        marketAddress = address(market);\n        \n        // Register market\n        allMarkets.push(marketAddress);\n        marketCount++;\n        \n        emit TTrustMarketCreated(\n            marketAddress,\n            msg.sender,\n            _predictionType,\n            _targetValue,\n            _deadline,\n            _title,\n            _predictionQuestion\n        );\n    }\n    \n    /**\n     * @notice Get market count\n     */\n    function getMarketCount() external view returns (uint256) {\n        return marketCount;\n    }\n    \n    /**\n     * @notice Get active markets (simple pagination)\n     */\n    function getActiveMarkets(uint256 _offset, uint256 _limit) \n        external \n        view \n        returns (address[] memory markets, uint256 total) \n    {\n        total = marketCount;\n        \n        if (_offset >= total) {\n            return (new address[](0), total);\n        }\n        \n        uint256 end = _offset + _limit;\n        if (end > total) {\n            end = total;\n        }\n        \n        markets = new address[](end - _offset);\n        for (uint256 i = _offset; i < end; i++) {\n            markets[i - _offset] = allMarkets[i];\n        }\n    }\n    \n    /**\n     * @notice Set oracle address\n     */\n    function setTTrustPriceOracle(address _oracle) external onlyOwner {\n        ttustPriceOracle = TTrustPriceOracle(_oracle);\n    }\n    \n    /**\n     * @notice Update fees\n     */\n    function setCreationFee(uint256 _fee) external onlyOwner {\n        creationFee = _fee;\n    }\n    \n    /**\n     * @notice Withdraw collected fees (native TTRUST)\n     */\n    function withdrawFees() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n    \n    /**\n     * @notice Emergency function to receive TTRUST\n     */\n    receive() external payable {}\n}"
    },
    "contracts/SimpleNativeMarket.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title SimpleNativeMarket\n * @notice Simple prediction market using native TTRUST\n */\ncontract SimpleNativeMarket is Ownable {\n    \n    enum PredictionType {\n        MARKET_CAP_ABOVE,\n        MARKET_CAP_BELOW,\n        PRICE_ABOVE,\n        PRICE_BELOW\n    }\n    \n    // Market details\n    PredictionType public predictionType;\n    uint256 public targetValue;\n    uint256 public deadline;\n    string public title;\n    string public predictionQuestion;\n    address public creator;\n    \n    // Market state\n    uint256 public totalLiquidity;\n    uint256 public yesPool;\n    uint256 public noPool;\n    bool public isResolved;\n    bool public targetReached;\n    \n    // User positions (in TTRUST wei)\n    mapping(address => uint256) public yesPositions;\n    mapping(address => uint256) public noPositions;\n    \n    // Events\n    event YesPurchased(address indexed buyer, uint256 amount, uint256 ttrust);\n    event NoPurchased(address indexed buyer, uint256 amount, uint256 ttrust);\n    event MarketResolved(bool targetReached);\n    event Redeemed(address indexed user, uint256 ttrust);\n    \n    constructor(\n        address _creator,\n        PredictionType _predictionType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _title,\n        string memory _predictionQuestion\n    ) payable Ownable(_creator) {\n        creator = _creator;\n        predictionType = _predictionType;\n        targetValue = _targetValue;\n        deadline = _deadline;\n        title = _title;\n        predictionQuestion = _predictionQuestion;\n        \n        // Initialize pools with sent TTRUST\n        totalLiquidity = msg.value;\n        yesPool = msg.value / 2;  // 50/50 initial split\n        noPool = msg.value / 2;\n        \n        require(msg.value > 0, \"Must provide initial liquidity\");\n    }\n    \n    /**\n     * @notice Buy YES tokens with native TTRUST\n     */\n    function buyYes() external payable {\n        require(msg.value > 0, \"Must send TTRUST\");\n        require(block.timestamp < deadline, \"Market expired\");\n        require(!isResolved, \"Market resolved\");\n        \n        uint256 yesToBuy = calculateYesToBuy(msg.value);\n        require(yesToBuy > 0, \"Invalid purchase amount\");\n        \n        yesPositions[msg.sender] += yesToBuy;\n        yesPool += msg.value;\n        \n        emit YesPurchased(msg.sender, yesToBuy, msg.value);\n    }\n    \n    /**\n     * @notice Buy NO tokens with native TTRUST  \n     */\n    function buyNo() external payable {\n        require(msg.value > 0, \"Must send TTRUST\");\n        require(block.timestamp < deadline, \"Market expired\");\n        require(!isResolved, \"Market resolved\");\n        \n        uint256 noToBuy = calculateNoToBuy(msg.value);\n        require(noToBuy > 0, \"Invalid purchase amount\");\n        \n        noPositions[msg.sender] += noToBuy;\n        noPool += msg.value;\n        \n        emit NoPurchased(msg.sender, noToBuy, msg.value);\n    }\n    \n    /**\n     * @notice Simple AMM pricing for YES tokens\n     */\n    function calculateYesToBuy(uint256 ttrust) public view returns (uint256) {\n        if (yesPool == 0) return ttrust;\n        // Simple formula: more expensive as pool grows\n        return (ttrust * 1e18) / (1e18 + yesPool * 1e18 / (yesPool + noPool));\n    }\n    \n    /**\n     * @notice Simple AMM pricing for NO tokens  \n     */\n    function calculateNoToBuy(uint256 ttrust) public view returns (uint256) {\n        if (noPool == 0) return ttrust;\n        // Simple formula: more expensive as pool grows\n        return (ttrust * 1e18) / (1e18 + noPool * 1e18 / (yesPool + noPool));\n    }\n    \n    /**\n     * @notice Get current YES price (TTRUST per YES token)\n     */\n    function getYesPrice() external view returns (uint256) {\n        if (yesPool == 0) return 1e18; // 1 TTRUST\n        return (yesPool * 1e18) / (yesPool + noPool);\n    }\n    \n    /**\n     * @notice Get current NO price (TTRUST per NO token)\n     */\n    function getNoPrice() external view returns (uint256) {\n        if (noPool == 0) return 1e18; // 1 TTRUST  \n        return (noPool * 1e18) / (yesPool + noPool);\n    }\n    \n    /**\n     * @notice Resolve market (only owner/oracle)\n     */\n    function resolveMarket(bool _targetReached) external onlyOwner {\n        require(block.timestamp >= deadline, \"Market not expired\");\n        require(!isResolved, \"Already resolved\");\n        \n        isResolved = true;\n        targetReached = _targetReached;\n        \n        emit MarketResolved(_targetReached);\n    }\n    \n    /**\n     * @notice Redeem winning positions\n     */\n    function redeem() external {\n        require(isResolved, \"Market not resolved\");\n        \n        uint256 payout = 0;\n        \n        if (targetReached && yesPositions[msg.sender] > 0) {\n            // YES won - calculate payout from total pool\n            payout = (yesPositions[msg.sender] * (yesPool + noPool)) / getTotalYesTokens();\n            yesPositions[msg.sender] = 0;\n        } else if (!targetReached && noPositions[msg.sender] > 0) {\n            // NO won - calculate payout from total pool\n            payout = (noPositions[msg.sender] * (yesPool + noPool)) / getTotalNoTokens();\n            noPositions[msg.sender] = 0;\n        }\n        \n        require(payout > 0, \"No payout available\");\n        \n        payable(msg.sender).transfer(payout);\n        emit Redeemed(msg.sender, payout);\n    }\n    \n    /**\n     * @notice Get total YES tokens issued (placeholder)\n     */\n    function getTotalYesTokens() public view returns (uint256) {\n        return yesPool; // Simplified for now\n    }\n    \n    /**\n     * @notice Get total NO tokens issued (placeholder)  \n     */\n    function getTotalNoTokens() public view returns (uint256) {\n        return noPool; // Simplified for now\n    }\n    \n    /**\n     * @notice Get market info\n     */\n    function getMarketInfo() external view returns (\n        string memory,\n        string memory, \n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        bool,\n        bool\n    ) {\n        return (\n            title,\n            predictionQuestion,\n            targetValue,\n            deadline, \n            yesPool,\n            noPool,\n            isResolved,\n            targetReached\n        );\n    }\n    \n    /**\n     * @notice Emergency receive function\n     */\n    receive() external payable {\n        // Allow contract to receive TTRUST\n    }\n}"
    },
    "contracts/TTrustPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { AggregatorV3Interface } from \"./interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title TTrustPriceOracle\n * @notice Oracle contract to get TTrust price data from multiple sources\n * @dev Can integrate with DEX prices, external oracles, or manual price feeds\n */\ncontract TTrustPriceOracle is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error TTrustPriceOracle__PriceStale();\n    error TTrustPriceOracle__InvalidPrice();\n    error TTrustPriceOracle__OnlyTrustedUpdater();\n    error TTrustPriceOracle__InvalidDEXAddress();\n    \n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n    \n    struct PriceData {\n        uint256 price;          // Price in USD (18 decimals)\n        uint256 timestamp;      // Last update timestamp\n        uint256 marketCap;      // Market cap in USD (18 decimals)\n        bool isValid;           // Is this price valid\n    }\n    \n    PriceData public currentPrice;\n    \n    uint256 public constant PRICE_STALENESS_THRESHOLD = 1 hours;\n    uint256 public constant PRECISION = 1e18;\n    \n    // Trusted price updaters (can be set to external oracles or bots)\n    mapping(address => bool) public trustedUpdaters;\n    \n    // DEX contract address for getting prices from liquidity pools\n    address public dexRouter;\n    address public ttustIntuitPair;\n    \n    // Backup price feeds (Chainlink style)\n    AggregatorV3Interface public backupPriceFeed;\n    \n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n    \n    event PriceUpdated(uint256 indexed price, uint256 indexed marketCap, uint256 timestamp, address updater);\n    event TrustedUpdaterSet(address indexed updater, bool trusted);\n    event DEXRouterSet(address indexed router, address indexed pair);\n    event BackupPriceFeedSet(address indexed priceFeed);\n    \n    /////////////////\n    /// Modifiers ///\n    /////////////////\n    \n    modifier onlyTrustedUpdater() {\n        if (!trustedUpdaters[msg.sender] && msg.sender != owner()) {\n            revert TTrustPriceOracle__OnlyTrustedUpdater();\n        }\n        _;\n    }\n    \n    //////////////////\n    ////Constructor///\n    //////////////////\n    \n    constructor(\n        address _owner,\n        uint256 _initialPrice,\n        uint256 _initialMarketCap\n    ) Ownable(_owner) {\n        // Set initial price data\n        currentPrice = PriceData({\n            price: _initialPrice,\n            timestamp: block.timestamp,\n            marketCap: _initialMarketCap,\n            isValid: true\n        });\n        \n        // Owner is automatically a trusted updater\n        trustedUpdaters[_owner] = true;\n        \n        emit PriceUpdated(_initialPrice, _initialMarketCap, block.timestamp, msg.sender);\n    }\n    \n    /////////////////\n    /// Functions ///\n    /////////////////\n    \n    /**\n     * @notice Update TTrust price manually (for trusted updaters)\n     * @param _price New price in USD (18 decimals)\n     * @param _marketCap New market cap in USD (18 decimals)\n     */\n    function updatePrice(uint256 _price, uint256 _marketCap) \n        external \n        onlyTrustedUpdater \n    {\n        if (_price == 0) {\n            revert TTrustPriceOracle__InvalidPrice();\n        }\n        \n        currentPrice = PriceData({\n            price: _price,\n            timestamp: block.timestamp,\n            marketCap: _marketCap,\n            isValid: true\n        });\n        \n        emit PriceUpdated(_price, _marketCap, block.timestamp, msg.sender);\n    }\n    \n    /**\n     * @notice Get current TTrust price\n     * @return price Current price in USD (18 decimals)\n     * @return timestamp Last update timestamp\n     */\n    function getPrice() external view returns (uint256 price, uint256 timestamp) {\n        if (!isPriceValid()) {\n            revert TTrustPriceOracle__PriceStale();\n        }\n        \n        return (currentPrice.price, currentPrice.timestamp);\n    }\n    \n    /**\n     * @notice Get current TTrust market cap\n     * @return marketCap Current market cap in USD (18 decimals)\n     * @return timestamp Last update timestamp\n     */\n    function getMarketCap() external view returns (uint256 marketCap, uint256 timestamp) {\n        if (!isPriceValid()) {\n            revert TTrustPriceOracle__PriceStale();\n        }\n        \n        return (currentPrice.marketCap, currentPrice.timestamp);\n    }\n    \n    /**\n     * @notice Check if current price is valid (not stale)\n     * @return bool True if price is valid\n     */\n    function isPriceValid() public view returns (bool) {\n        return currentPrice.isValid && \n               (block.timestamp - currentPrice.timestamp) <= PRICE_STALENESS_THRESHOLD;\n    }\n    \n    /**\n     * @notice Get price from DEX (if configured)\n     * @return price Price from DEX\n     */\n    function getPriceFromDEX() external view returns (uint256 price) {\n        // This would integrate with the existing DEX to get TTrust price\n        // Implementation depends on the DEX structure\n        if (dexRouter == address(0)) {\n            return 0;\n        }\n        \n        // TODO: Implement actual DEX price fetching\n        // For now, return current price as fallback\n        return currentPrice.price;\n    }\n    \n    /////////////////////////\n    /// Admin Functions ////\n    /////////////////////////\n    \n    /**\n     * @notice Set trusted updater status\n     * @param _updater Address to set trust status for\n     * @param _trusted Whether this address is trusted\n     */\n    function setTrustedUpdater(address _updater, bool _trusted) external onlyOwner {\n        trustedUpdaters[_updater] = _trusted;\n        emit TrustedUpdaterSet(_updater, _trusted);\n    }\n    \n    /**\n     * @notice Set DEX router and pair addresses for price fetching\n     * @param _router DEX router address\n     * @param _pair TTrust/INTUIT pair address\n     */\n    function setDEXAddresses(address _router, address _pair) external onlyOwner {\n        if (_router == address(0) || _pair == address(0)) {\n            revert TTrustPriceOracle__InvalidDEXAddress();\n        }\n        \n        dexRouter = _router;\n        ttustIntuitPair = _pair;\n        \n        emit DEXRouterSet(_router, _pair);\n    }\n    \n    /**\n     * @notice Set backup price feed (Chainlink style)\n     * @param _priceFeed Chainlink price feed address\n     */\n    function setBackupPriceFeed(address _priceFeed) external onlyOwner {\n        backupPriceFeed = AggregatorV3Interface(_priceFeed);\n        emit BackupPriceFeedSet(_priceFeed);\n    }\n    \n    /**\n     * @notice Emergency function to invalidate current price\n     */\n    function invalidatePrice() external onlyOwner {\n        currentPrice.isValid = false;\n    }\n    \n    /////////////////////////\n    /// Getter Functions ///\n    /////////////////////////\n    \n    /**\n     * @notice Get all price data\n     */\n    function getAllPriceData() \n        external \n        view \n        returns (\n            uint256 price,\n            uint256 timestamp,\n            uint256 marketCap,\n            bool isValid,\n            bool isStale\n        ) \n    {\n        price = currentPrice.price;\n        timestamp = currentPrice.timestamp;\n        marketCap = currentPrice.marketCap;\n        isValid = currentPrice.isValid;\n        isStale = !isPriceValid();\n    }\n}"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}