{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/IntuitionMetricsOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title IntuitionMetricsOracle\n * @notice Oracle contract to track Intuition blockchain metrics\n * @dev Tracks atoms, triplets, and signals creation on Intuition network\n */\ncontract IntuitionMetricsOracle is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error IntuitionMetricsOracle__DataStale();\n    error IntuitionMetricsOracle__OnlyTrustedUpdater();\n    error IntuitionMetricsOracle__InvalidMetric();\n    \n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n    \n    enum MetricType {\n        ATOMS,\n        TRIPLETS, \n        SIGNALS\n    }\n    \n    struct MetricData {\n        uint256 count;          // Current count of this metric\n        uint256 timestamp;      // Last update timestamp\n        uint256 dailyGrowth;    // Growth in the last 24h\n        uint256 weeklyGrowth;   // Growth in the last 7 days\n        bool isValid;           // Is this data valid\n    }\n    \n    // Mapping from MetricType to current data\n    mapping(MetricType => MetricData) public metrics;\n    \n    // Historical snapshots for trend analysis\n    struct Snapshot {\n        uint256 atomsCount;\n        uint256 tripletsCount;\n        uint256 signalsCount;\n        uint256 timestamp;\n    }\n    \n    Snapshot[] public snapshots;\n    \n    uint256 public constant DATA_STALENESS_THRESHOLD = 4 hours;\n    \n    // Trusted data updaters (off-chain services that call explorer API)\n    mapping(address => bool) public trustedUpdaters;\n    \n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n    \n    event MetricUpdated(\n        MetricType indexed metricType, \n        uint256 indexed count, \n        uint256 dailyGrowth,\n        uint256 weeklyGrowth,\n        uint256 timestamp,\n        address updater\n    );\n    \n    event SnapshotTaken(\n        uint256 indexed snapshotId,\n        uint256 atomsCount,\n        uint256 tripletsCount, \n        uint256 signalsCount,\n        uint256 timestamp\n    );\n    \n    event TrustedUpdaterSet(address indexed updater, bool trusted);\n    \n    /////////////////\n    /// Modifiers ///\n    /////////////////\n    \n    modifier onlyTrustedUpdater() {\n        if (!trustedUpdaters[msg.sender] && msg.sender != owner()) {\n            revert IntuitionMetricsOracle__OnlyTrustedUpdater();\n        }\n        _;\n    }\n    \n    //////////////////\n    ////Constructor///\n    //////////////////\n    \n    constructor(\n        address _owner,\n        uint256 _initialAtoms,\n        uint256 _initialTriplets,\n        uint256 _initialSignals\n    ) Ownable(_owner) {\n        \n        // Initialize metrics with current values\n        metrics[MetricType.ATOMS] = MetricData({\n            count: _initialAtoms,\n            timestamp: block.timestamp,\n            dailyGrowth: 0,\n            weeklyGrowth: 0,\n            isValid: true\n        });\n        \n        metrics[MetricType.TRIPLETS] = MetricData({\n            count: _initialTriplets,\n            timestamp: block.timestamp,\n            dailyGrowth: 0,\n            weeklyGrowth: 0,\n            isValid: true\n        });\n        \n        metrics[MetricType.SIGNALS] = MetricData({\n            count: _initialSignals,\n            timestamp: block.timestamp,\n            dailyGrowth: 0,\n            weeklyGrowth: 0,\n            isValid: true\n        });\n        \n        // Owner is automatically a trusted updater\n        trustedUpdaters[_owner] = true;\n        \n        // Take initial snapshot\n        _takeSnapshot();\n    }\n    \n    /////////////////\n    /// Functions ///\n    /////////////////\n    \n    /**\n     * @notice Update multiple metrics at once\n     * @param _atomsCount Current atoms count\n     * @param _tripletsCount Current triplets count  \n     * @param _signalsCount Current signals count\n     */\n    function updateAllMetrics(\n        uint256 _atomsCount,\n        uint256 _tripletsCount,\n        uint256 _signalsCount\n    ) external onlyTrustedUpdater {\n        \n        // Calculate growth for each metric\n        uint256 atomsDailyGrowth = _calculateGrowth(MetricType.ATOMS, _atomsCount, 1 days);\n        uint256 atomsWeeklyGrowth = _calculateGrowth(MetricType.ATOMS, _atomsCount, 7 days);\n        \n        uint256 tripletsDailyGrowth = _calculateGrowth(MetricType.TRIPLETS, _tripletsCount, 1 days);\n        uint256 tripletsWeeklyGrowth = _calculateGrowth(MetricType.TRIPLETS, _tripletsCount, 7 days);\n        \n        uint256 signalsDailyGrowth = _calculateGrowth(MetricType.SIGNALS, _signalsCount, 1 days);\n        uint256 signalsWeeklyGrowth = _calculateGrowth(MetricType.SIGNALS, _signalsCount, 7 days);\n        \n        // Update atoms\n        metrics[MetricType.ATOMS] = MetricData({\n            count: _atomsCount,\n            timestamp: block.timestamp,\n            dailyGrowth: atomsDailyGrowth,\n            weeklyGrowth: atomsWeeklyGrowth,\n            isValid: true\n        });\n        \n        // Update triplets\n        metrics[MetricType.TRIPLETS] = MetricData({\n            count: _tripletsCount,\n            timestamp: block.timestamp,\n            dailyGrowth: tripletsDailyGrowth,\n            weeklyGrowth: tripletsWeeklyGrowth,\n            isValid: true\n        });\n        \n        // Update signals\n        metrics[MetricType.SIGNALS] = MetricData({\n            count: _signalsCount,\n            timestamp: block.timestamp,\n            dailyGrowth: signalsDailyGrowth,\n            weeklyGrowth: signalsWeeklyGrowth,\n            isValid: true\n        });\n        \n        emit MetricUpdated(MetricType.ATOMS, _atomsCount, atomsDailyGrowth, atomsWeeklyGrowth, block.timestamp, msg.sender);\n        emit MetricUpdated(MetricType.TRIPLETS, _tripletsCount, tripletsDailyGrowth, tripletsWeeklyGrowth, block.timestamp, msg.sender);\n        emit MetricUpdated(MetricType.SIGNALS, _signalsCount, signalsDailyGrowth, signalsWeeklyGrowth, block.timestamp, msg.sender);\n        \n        // Take snapshot every update\n        _takeSnapshot();\n    }\n    \n    /**\n     * @notice Update a single metric\n     * @param _metricType Type of metric to update\n     * @param _count New count value\n     */\n    function updateMetric(MetricType _metricType, uint256 _count) \n        external \n        onlyTrustedUpdater \n    {\n        uint256 dailyGrowth = _calculateGrowth(_metricType, _count, 1 days);\n        uint256 weeklyGrowth = _calculateGrowth(_metricType, _count, 7 days);\n        \n        metrics[_metricType] = MetricData({\n            count: _count,\n            timestamp: block.timestamp,\n            dailyGrowth: dailyGrowth,\n            weeklyGrowth: weeklyGrowth,\n            isValid: true\n        });\n        \n        emit MetricUpdated(_metricType, _count, dailyGrowth, weeklyGrowth, block.timestamp, msg.sender);\n    }\n    \n    /**\n     * @notice Get current count for a specific metric\n     * @param _metricType Type of metric to query\n     * @return count Current count\n     * @return timestamp Last update timestamp\n     */\n    function getMetricCount(MetricType _metricType) \n        external \n        view \n        returns (uint256 count, uint256 timestamp) \n    {\n        if (!isMetricValid(_metricType)) {\n            revert IntuitionMetricsOracle__DataStale();\n        }\n        \n        MetricData memory data = metrics[_metricType];\n        return (data.count, data.timestamp);\n    }\n    \n    /**\n     * @notice Get full metric data including growth\n     * @param _metricType Type of metric to query\n     */\n    function getFullMetricData(MetricType _metricType)\n        external\n        view\n        returns (\n            uint256 count,\n            uint256 timestamp,\n            uint256 dailyGrowth,\n            uint256 weeklyGrowth,\n            bool isValid\n        )\n    {\n        MetricData memory data = metrics[_metricType];\n        return (\n            data.count,\n            data.timestamp,\n            data.dailyGrowth,\n            data.weeklyGrowth,\n            isMetricValid(_metricType)\n        );\n    }\n    \n    /**\n     * @notice Get all current metrics at once\n     */\n    function getAllMetrics()\n        external\n        view\n        returns (\n            uint256 atomsCount,\n            uint256 tripletsCount,\n            uint256 signalsCount,\n            uint256 lastUpdate\n        )\n    {\n        atomsCount = metrics[MetricType.ATOMS].count;\n        tripletsCount = metrics[MetricType.TRIPLETS].count;\n        signalsCount = metrics[MetricType.SIGNALS].count;\n        \n        // Return the most recent update time\n        uint256 atomsTime = metrics[MetricType.ATOMS].timestamp;\n        uint256 tripletsTime = metrics[MetricType.TRIPLETS].timestamp;\n        uint256 signalsTime = metrics[MetricType.SIGNALS].timestamp;\n        \n        lastUpdate = atomsTime;\n        if (tripletsTime > lastUpdate) lastUpdate = tripletsTime;\n        if (signalsTime > lastUpdate) lastUpdate = signalsTime;\n    }\n    \n    /**\n     * @notice Check if metric data is valid (not stale)\n     * @param _metricType Type of metric to check\n     * @return bool True if data is valid\n     */\n    function isMetricValid(MetricType _metricType) public view returns (bool) {\n        MetricData memory data = metrics[_metricType];\n        return data.isValid && \n               (block.timestamp - data.timestamp) <= DATA_STALENESS_THRESHOLD;\n    }\n    \n    /**\n     * @notice Get growth data for trend predictions\n     * @param _metricType Type of metric\n     * @return dailyGrowth Growth in last 24h\n     * @return weeklyGrowth Growth in last 7 days\n     */\n    function getGrowthData(MetricType _metricType) \n        external \n        view \n        returns (uint256 dailyGrowth, uint256 weeklyGrowth) \n    {\n        MetricData memory data = metrics[_metricType];\n        return (data.dailyGrowth, data.weeklyGrowth);\n    }\n    \n    /////////////////////////\n    /// Internal Functions //\n    /////////////////////////\n    \n    /**\n     * @dev Calculate growth compared to historical data\n     */\n    function _calculateGrowth(\n        MetricType _metricType, \n        uint256 _newCount, \n        uint256 _timeWindow\n    ) internal view returns (uint256 growth) {\n        \n        uint256 cutoffTime = block.timestamp - _timeWindow;\n        uint256 oldCount = metrics[_metricType].count;\n        \n        // Look for snapshot closest to cutoff time\n        for (uint i = snapshots.length; i > 0; i--) {\n            Snapshot memory snap = snapshots[i-1];\n            if (snap.timestamp <= cutoffTime) {\n                if (_metricType == MetricType.ATOMS) {\n                    oldCount = snap.atomsCount;\n                } else if (_metricType == MetricType.TRIPLETS) {\n                    oldCount = snap.tripletsCount;\n                } else if (_metricType == MetricType.SIGNALS) {\n                    oldCount = snap.signalsCount;\n                }\n                break;\n            }\n        }\n        \n        return _newCount > oldCount ? _newCount - oldCount : 0;\n    }\n    \n    /**\n     * @dev Take a snapshot of current metrics\n     */\n    function _takeSnapshot() internal {\n        snapshots.push(Snapshot({\n            atomsCount: metrics[MetricType.ATOMS].count,\n            tripletsCount: metrics[MetricType.TRIPLETS].count,\n            signalsCount: metrics[MetricType.SIGNALS].count,\n            timestamp: block.timestamp\n        }));\n        \n        emit SnapshotTaken(\n            snapshots.length - 1,\n            metrics[MetricType.ATOMS].count,\n            metrics[MetricType.TRIPLETS].count,\n            metrics[MetricType.SIGNALS].count,\n            block.timestamp\n        );\n        \n        // Keep only last 100 snapshots to avoid excessive gas costs\n        if (snapshots.length > 100) {\n            for (uint i = 0; i < snapshots.length - 100; i++) {\n                snapshots[i] = snapshots[i + 1];\n            }\n            snapshots.pop();\n        }\n    }\n    \n    /////////////////////////\n    /// Admin Functions ////\n    /////////////////////////\n    \n    /**\n     * @notice Set trusted updater status\n     * @param _updater Address to set trust status for\n     * @param _trusted Whether this address is trusted\n     */\n    function setTrustedUpdater(address _updater, bool _trusted) external onlyOwner {\n        trustedUpdaters[_updater] = _trusted;\n        emit TrustedUpdaterSet(_updater, _trusted);\n    }\n    \n    /**\n     * @notice Emergency function to invalidate metric data\n     * @param _metricType Metric to invalidate\n     */\n    function invalidateMetric(MetricType _metricType) external onlyOwner {\n        metrics[_metricType].isValid = false;\n    }\n    \n    /////////////////////////\n    /// Getter Functions ///\n    /////////////////////////\n    \n    /**\n     * @notice Get number of stored snapshots\n     */\n    function getSnapshotCount() external view returns (uint256) {\n        return snapshots.length;\n    }\n    \n    /**\n     * @notice Get specific snapshot\n     * @param _index Snapshot index\n     */\n    function getSnapshot(uint256 _index) \n        external \n        view \n        returns (\n            uint256 atomsCount,\n            uint256 tripletsCount,\n            uint256 signalsCount,\n            uint256 timestamp\n        ) \n    {\n        require(_index < snapshots.length, \"Snapshot index out of bounds\");\n        Snapshot memory snap = snapshots[_index];\n        return (snap.atomsCount, snap.tripletsCount, snap.signalsCount, snap.timestamp);\n    }\n}"
    },
    "contracts/IntuitionMetricsPrediction.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { PredictionMarket } from \"./PredictionMarket.sol\";\nimport { IntuitionMetricsOracle } from \"./IntuitionMetricsOracle.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title IntuitionMetricsPrediction\n * @notice Prediction market for Intuition blockchain metrics (atoms, triplets, signals)\n * @dev Allows predictions on reaching certain thresholds for network metrics\n */\ncontract IntuitionMetricsPrediction is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error IntuitionMetricsPrediction__MarketNotResolved();\n    error IntuitionMetricsPrediction__MarketAlreadyResolved();\n    error IntuitionMetricsPrediction__DeadlinePassed();\n    error IntuitionMetricsPrediction__DeadlineNotReached();\n    error IntuitionMetricsPrediction__InvalidTargetValue();\n    error IntuitionMetricsPrediction__OracleDataStale();\n    error IntuitionMetricsPrediction__InvalidMetricType();\n    \n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n    \n    enum MetricType {\n        ATOMS_COUNT,        // Total atoms created\n        TRIPLETS_COUNT,     // Total triplets created\n        SIGNALS_COUNT,      // Total signals created\n        ATOMS_GROWTH,       // Daily atoms growth\n        TRIPLETS_GROWTH,    // Daily triplets growth\n        SIGNALS_GROWTH      // Daily signals growth\n    }\n    \n    enum ComparisonType {\n        ABOVE_THRESHOLD,    // Metric will be above threshold\n        BELOW_THRESHOLD,    // Metric will be below threshold\n        EXACT_VALUE         // Metric will equal exact value (with tolerance)\n    }\n    \n    struct MetricPrediction {\n        MetricType metricType;\n        ComparisonType comparisonType;\n        uint256 targetValue;        // Target count/growth value\n        uint256 tolerance;          // For EXACT_VALUE predictions (±tolerance)\n        uint256 deadline;           // When prediction expires\n        string description;         // Human readable description\n        bool isResolved;           // Has this prediction been resolved\n        bool targetReached;        // Did target get reached\n        uint256 actualValue;       // Actual value at resolution time\n        uint256 resolutionTime;    // When it was resolved\n        uint256 baselineValue;     // Starting value (for growth calculations)\n        uint256 baselineTime;      // When baseline was recorded\n    }\n    \n    // Core prediction market contract (handles token trading)\n    PredictionMarket public immutable predictionMarket;\n    \n    // Oracle for Intuition metrics data\n    IntuitionMetricsOracle public immutable metricsOracle;\n    \n    // Prediction details\n    MetricPrediction public prediction;\n    \n    uint256 public constant PRECISION = 1e18;\n    uint256 public constant RESOLUTION_BUFFER = 2 hours; // Grace period after deadline\n    uint256 public constant MAX_TOLERANCE_PERCENTAGE = 10; // 10% max tolerance for exact values\n    \n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n    \n    event MetricPredictionCreated(\n        MetricType indexed metricType,\n        ComparisonType indexed comparisonType,\n        uint256 indexed targetValue,\n        uint256 deadline,\n        string description\n    );\n    \n    event PredictionResolved(\n        bool indexed targetReached,\n        uint256 actualValue,\n        uint256 targetValue,\n        uint256 resolutionTime\n    );\n    \n    event BaselineUpdated(\n        uint256 baselineValue,\n        uint256 baselineTime\n    );\n    \n    event EmergencyResolution(\n        bool targetReached,\n        string reason\n    );\n    \n    /////////////////\n    /// Modifiers ///\n    /////////////////\n    \n    modifier beforeDeadline() {\n        if (block.timestamp >= prediction.deadline) {\n            revert IntuitionMetricsPrediction__DeadlinePassed();\n        }\n        _;\n    }\n    \n    modifier afterDeadline() {\n        if (block.timestamp < prediction.deadline + RESOLUTION_BUFFER) {\n            revert IntuitionMetricsPrediction__DeadlineNotReached();\n        }\n        _;\n    }\n    \n    modifier notResolved() {\n        if (prediction.isResolved) {\n            revert IntuitionMetricsPrediction__MarketAlreadyResolved();\n        }\n        _;\n    }\n    \n    modifier resolved() {\n        if (!prediction.isResolved) {\n            revert IntuitionMetricsPrediction__MarketNotResolved();\n        }\n        _;\n    }\n    \n    //////////////////\n    ////Constructor///\n    //////////////////\n    \n    constructor(\n        address _liquidityProvider,\n        address _metricsOracle,\n        MetricType _metricType,\n        ComparisonType _comparisonType,\n        uint256 _targetValue,\n        uint256 _tolerance,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _initialTokenValue,\n        uint8 _initialYesProbability,\n        uint8 _percentageToLock\n    ) payable Ownable(_liquidityProvider) {\n        \n        if (_targetValue == 0) {\n            revert IntuitionMetricsPrediction__InvalidTargetValue();\n        }\n        \n        if (_deadline <= block.timestamp) {\n            revert IntuitionMetricsPrediction__DeadlinePassed();\n        }\n        \n        // Validate tolerance for exact value predictions\n        if (_comparisonType == ComparisonType.EXACT_VALUE) {\n            require(_tolerance <= (_targetValue * MAX_TOLERANCE_PERCENTAGE) / 100, \"Tolerance too high\");\n        }\n        \n        // Set oracle\n        metricsOracle = IntuitionMetricsOracle(_metricsOracle);\n        \n        // Get current baseline value\n        (uint256 currentValue, uint256 currentTime) = _getCurrentMetricValue(_metricType);\n        \n        // Store prediction details\n        prediction = MetricPrediction({\n            metricType: _metricType,\n            comparisonType: _comparisonType,\n            targetValue: _targetValue,\n            tolerance: _tolerance,\n            deadline: _deadline,\n            description: _description,\n            isResolved: false,\n            targetReached: false,\n            actualValue: 0,\n            resolutionTime: 0,\n            baselineValue: currentValue,\n            baselineTime: currentTime\n        });\n        \n        // Create underlying prediction market\n        string memory question = _buildQuestionString(\n            _metricType, \n            _comparisonType, \n            _targetValue, \n            _deadline, \n            _description\n        );\n        \n        predictionMarket = new PredictionMarket{value: msg.value}(\n            _liquidityProvider,\n            address(this), // This contract acts as oracle\n            question,\n            _initialTokenValue,\n            _initialYesProbability,\n            _percentageToLock\n        );\n        \n        emit MetricPredictionCreated(_metricType, _comparisonType, _targetValue, _deadline, _description);\n        emit BaselineUpdated(currentValue, currentTime);\n    }\n    \n    /////////////////\n    /// Functions ///\n    /////////////////\n    \n    /**\n     * @notice Buy prediction tokens (YES = target will be reached, NO = target won't be reached)\n     */\n    function buyTokens(PredictionMarket.Outcome _outcome, uint256 _amountTokenToBuy) \n        external \n        payable\n        beforeDeadline\n        notResolved\n    {\n        predictionMarket.buyTokensWithETH{value: msg.value}(_outcome, _amountTokenToBuy);\n    }\n    \n    /**\n     * @notice Sell prediction tokens back to the market\n     */\n    function sellTokens(PredictionMarket.Outcome _outcome, uint256 _tradingAmount)\n        external\n        beforeDeadline\n        notResolved\n    {\n        predictionMarket.sellTokensForEth(_outcome, _tradingAmount);\n    }\n    \n    /**\n     * @notice Resolve the prediction by checking current Intuition metrics\n     */\n    function resolvePrediction() external afterDeadline notResolved {\n        \n        // Get current metric value\n        (uint256 currentValue, uint256 timestamp) = _getCurrentMetricValue(prediction.metricType);\n        \n        // Check if oracle data is fresh enough\n        if (block.timestamp - timestamp > 4 hours) {\n            revert IntuitionMetricsPrediction__OracleDataStale();\n        }\n        \n        // For growth metrics, calculate growth since baseline\n        uint256 actualValue = currentValue;\n        if (_isGrowthMetric(prediction.metricType)) {\n            actualValue = currentValue > prediction.baselineValue ? \n                currentValue - prediction.baselineValue : 0;\n        }\n        \n        // Determine if target was reached\n        bool targetReached = _evaluateTarget(actualValue);\n        \n        // Update prediction state\n        prediction.isResolved = true;\n        prediction.targetReached = targetReached;\n        prediction.actualValue = actualValue;\n        prediction.resolutionTime = block.timestamp;\n        \n        // Report to underlying prediction market\n        PredictionMarket.Outcome winningOutcome = targetReached ? \n            PredictionMarket.Outcome.YES : \n            PredictionMarket.Outcome.NO;\n            \n        predictionMarket.report(winningOutcome);\n        \n        emit PredictionResolved(targetReached, actualValue, prediction.targetValue, block.timestamp);\n    }\n    \n    /**\n     * @notice Update baseline for growth metrics (owner only, before deadline)\n     */\n    function updateBaseline() external onlyOwner beforeDeadline notResolved {\n        if (!_isGrowthMetric(prediction.metricType)) {\n            return; // Only applies to growth metrics\n        }\n        \n        (uint256 currentValue, uint256 currentTime) = _getCurrentMetricValue(prediction.metricType);\n        \n        prediction.baselineValue = currentValue;\n        prediction.baselineTime = currentTime;\n        \n        emit BaselineUpdated(currentValue, currentTime);\n    }\n    \n    /**\n     * @notice Emergency resolution by owner\n     */\n    function emergencyResolve(bool _targetReached, string memory _reason) \n        external \n        onlyOwner \n        notResolved \n    {\n        prediction.isResolved = true;\n        prediction.targetReached = _targetReached;\n        prediction.resolutionTime = block.timestamp;\n        \n        PredictionMarket.Outcome winningOutcome = _targetReached ? \n            PredictionMarket.Outcome.YES : \n            PredictionMarket.Outcome.NO;\n            \n        predictionMarket.report(winningOutcome);\n        \n        emit EmergencyResolution(_targetReached, _reason);\n    }\n    \n    /**\n     * @notice Redeem winning tokens after resolution\n     */\n    function redeemWinningTokens(uint256 _amount) external resolved {\n        predictionMarket.redeemWinningTokens(_amount);\n    }\n    \n    /**\n     * @notice Owner can withdraw profits after resolution\n     */\n    function withdrawProfits() external onlyOwner resolved {\n        predictionMarket.resolveMarketAndWithdraw();\n    }\n    \n    /////////////////////////\n    /// Internal Functions //\n    /////////////////////////\n    \n    /**\n     * @dev Get current metric value from oracle\n     */\n    function _getCurrentMetricValue(MetricType _metricType) \n        internal \n        view \n        returns (uint256 value, uint256 timestamp) \n    {\n        if (_metricType == MetricType.ATOMS_COUNT || _metricType == MetricType.ATOMS_GROWTH) {\n            return metricsOracle.getMetricCount(IntuitionMetricsOracle.MetricType.ATOMS);\n        } else if (_metricType == MetricType.TRIPLETS_COUNT || _metricType == MetricType.TRIPLETS_GROWTH) {\n            return metricsOracle.getMetricCount(IntuitionMetricsOracle.MetricType.TRIPLETS);\n        } else if (_metricType == MetricType.SIGNALS_COUNT || _metricType == MetricType.SIGNALS_GROWTH) {\n            return metricsOracle.getMetricCount(IntuitionMetricsOracle.MetricType.SIGNALS);\n        } else {\n            revert IntuitionMetricsPrediction__InvalidMetricType();\n        }\n    }\n    \n    /**\n     * @dev Check if metric type is growth-based\n     */\n    function _isGrowthMetric(MetricType _metricType) internal pure returns (bool) {\n        return _metricType == MetricType.ATOMS_GROWTH ||\n               _metricType == MetricType.TRIPLETS_GROWTH ||\n               _metricType == MetricType.SIGNALS_GROWTH;\n    }\n    \n    /**\n     * @dev Evaluate if target was reached\n     */\n    function _evaluateTarget(uint256 actualValue) internal view returns (bool) {\n        if (prediction.comparisonType == ComparisonType.ABOVE_THRESHOLD) {\n            return actualValue >= prediction.targetValue;\n        } else if (prediction.comparisonType == ComparisonType.BELOW_THRESHOLD) {\n            return actualValue <= prediction.targetValue;\n        } else { // EXACT_VALUE\n            uint256 diff = actualValue > prediction.targetValue ? \n                actualValue - prediction.targetValue : \n                prediction.targetValue - actualValue;\n            return diff <= prediction.tolerance;\n        }\n    }\n    \n    /**\n     * @dev Build human-readable question string\n     */\n    function _buildQuestionString(\n        MetricType _metricType,\n        ComparisonType _comparisonType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _description\n    ) internal pure returns (string memory) {\n        \n        string memory metricName;\n        if (_metricType == MetricType.ATOMS_COUNT) metricName = \"atoms count\";\n        else if (_metricType == MetricType.TRIPLETS_COUNT) metricName = \"triplets count\";\n        else if (_metricType == MetricType.SIGNALS_COUNT) metricName = \"signals count\";\n        else if (_metricType == MetricType.ATOMS_GROWTH) metricName = \"atoms growth\";\n        else if (_metricType == MetricType.TRIPLETS_GROWTH) metricName = \"triplets growth\";\n        else if (_metricType == MetricType.SIGNALS_GROWTH) metricName = \"signals growth\";\n        \n        string memory comparisonText;\n        if (_comparisonType == ComparisonType.ABOVE_THRESHOLD) comparisonText = \"exceed\";\n        else if (_comparisonType == ComparisonType.BELOW_THRESHOLD) comparisonText = \"stay below\";\n        else comparisonText = \"equal approximately\";\n        \n        return string(abi.encodePacked(\n            \"Will Intuition \", metricName, \" \", comparisonText, \" the target by deadline? \", _description\n        ));\n    }\n    \n    /////////////////////////\n    /// View Functions //////\n    /////////////////////////\n    \n    /**\n     * @notice Get current Intuition metrics for display\n     */\n    function getCurrentMetrics() \n        external \n        view \n        returns (\n            uint256 currentAtoms,\n            uint256 currentTriplets,\n            uint256 currentSignals,\n            uint256 lastUpdate\n        ) \n    {\n        return metricsOracle.getAllMetrics();\n    }\n    \n    /**\n     * @notice Get current prediction target vs actual\n     */\n    function getPredictionProgress()\n        external\n        view\n        returns (\n            uint256 targetValue,\n            uint256 currentValue,\n            uint256 progressPercentage,\n            bool targetReached,\n            uint256 timeRemaining\n        )\n    {\n        targetValue = prediction.targetValue;\n        \n        try this.getCurrentPredictionValue() returns (uint256 current) {\n            currentValue = current;\n            \n            if (prediction.comparisonType == ComparisonType.ABOVE_THRESHOLD) {\n                progressPercentage = targetValue > 0 ? (currentValue * 100) / targetValue : 0;\n                targetReached = currentValue >= targetValue;\n            } else if (prediction.comparisonType == ComparisonType.BELOW_THRESHOLD) {\n                progressPercentage = currentValue <= targetValue ? 100 : 0;\n                targetReached = currentValue <= targetValue;\n            } else { // EXACT_VALUE\n                uint256 diff = currentValue > targetValue ? currentValue - targetValue : targetValue - currentValue;\n                progressPercentage = diff <= prediction.tolerance ? 100 : 0;\n                targetReached = diff <= prediction.tolerance;\n            }\n        } catch {\n            currentValue = 0;\n            progressPercentage = 0;\n            targetReached = false;\n        }\n        \n        timeRemaining = block.timestamp < prediction.deadline ? \n            prediction.deadline - block.timestamp : 0;\n    }\n    \n    /**\n     * @notice Get current value for this prediction (handles growth calculations)\n     */\n    function getCurrentPredictionValue() external view returns (uint256) {\n        (uint256 currentValue,) = _getCurrentMetricValue(prediction.metricType);\n        \n        if (_isGrowthMetric(prediction.metricType)) {\n            return currentValue > prediction.baselineValue ? \n                currentValue - prediction.baselineValue : 0;\n        }\n        \n        return currentValue;\n    }\n    \n    /**\n     * @notice Get complete prediction information\n     */\n    function getPredictionInfo()\n        external\n        view\n        returns (\n            MetricType metricType,\n            ComparisonType comparisonType,\n            uint256 targetValue,\n            uint256 tolerance,\n            uint256 deadline,\n            string memory description,\n            bool isResolved,\n            bool targetReached,\n            uint256 actualValue,\n            uint256 resolutionTime,\n            address predictionMarketAddress\n        )\n    {\n        return (\n            prediction.metricType,\n            prediction.comparisonType,\n            prediction.targetValue,\n            prediction.tolerance,\n            prediction.deadline,\n            prediction.description,\n            prediction.isResolved,\n            prediction.targetReached,\n            prediction.actualValue,\n            prediction.resolutionTime,\n            address(predictionMarket)\n        );\n    }\n    \n    /**\n     * @notice Check if prediction can be resolved\n     */\n    function canResolve() external view returns (bool) {\n        return !prediction.isResolved && \n               block.timestamp >= prediction.deadline + RESOLUTION_BUFFER &&\n               metricsOracle.isMetricValid(_mapToOracleMetricType(prediction.metricType));\n    }\n    \n    /**\n     * @dev Map internal metric type to oracle metric type\n     */\n    function _mapToOracleMetricType(MetricType _metricType) \n        internal \n        pure \n        returns (IntuitionMetricsOracle.MetricType) \n    {\n        if (_metricType == MetricType.ATOMS_COUNT || _metricType == MetricType.ATOMS_GROWTH) {\n            return IntuitionMetricsOracle.MetricType.ATOMS;\n        } else if (_metricType == MetricType.TRIPLETS_COUNT || _metricType == MetricType.TRIPLETS_GROWTH) {\n            return IntuitionMetricsOracle.MetricType.TRIPLETS;\n        } else {\n            return IntuitionMetricsOracle.MetricType.SIGNALS;\n        }\n    }\n}"
    },
    "contracts/IntuitionMetricsPredictionTTrust.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { PredictionMarketTTrust } from \"./PredictionMarketTTrust.sol\";\nimport { IntuitionMetricsOracle } from \"./IntuitionMetricsOracle.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title IntuitionMetricsPredictionTTrust\n * @notice Prediction market for Intuition blockchain metrics using TTrust as currency\n * @dev Allows predictions on reaching certain thresholds for network metrics with TTrust payments\n */\ncontract IntuitionMetricsPredictionTTrust is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error IntuitionMetricsPredictionTTrust__MarketNotResolved();\n    error IntuitionMetricsPredictionTTrust__MarketAlreadyResolved();\n    error IntuitionMetricsPredictionTTrust__DeadlinePassed();\n    error IntuitionMetricsPredictionTTrust__DeadlineNotReached();\n    error IntuitionMetricsPredictionTTrust__InvalidTargetValue();\n    error IntuitionMetricsPredictionTTrust__OracleDataStale();\n    error IntuitionMetricsPredictionTTrust__InvalidMetricType();\n\n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n\n    enum MetricType {\n        ATOMS_COUNT,        // Total atoms created\n        TRIPLETS_COUNT,     // Total triplets created\n        SIGNALS_COUNT,      // Total signals created\n        ATOMS_GROWTH,       // Daily atoms growth\n        TRIPLETS_GROWTH,    // Daily triplets growth\n        SIGNALS_GROWTH      // Daily signals growth\n    }\n\n    enum ComparisonType {\n        ABOVE_THRESHOLD,    // Metric will be above threshold\n        BELOW_THRESHOLD,    // Metric will be below threshold\n        EXACT_VALUE         // Metric will equal exact value (with tolerance)\n    }\n\n    struct MetricPrediction {\n        MetricType metricType;\n        ComparisonType comparisonType;\n        uint256 targetValue;        // Target count/growth value\n        uint256 tolerance;          // For EXACT_VALUE predictions (±tolerance)\n        uint256 deadline;           // When prediction expires\n        string description;         // Human readable description\n        bool isResolved;           // Has this prediction been resolved\n        bool targetReached;        // Did target get reached\n        uint256 actualValue;       // Actual value at resolution time\n        uint256 resolutionTime;    // When it was resolved\n        uint256 baselineValue;     // Starting value (for growth calculations)\n        uint256 baselineTime;      // When baseline was recorded\n    }\n\n    // Core prediction market contract (handles token trading with TTrust)\n    PredictionMarketTTrust public immutable predictionMarket;\n\n    // Oracle for Intuition metrics data\n    IntuitionMetricsOracle public immutable metricsOracle;\n\n    // TTrust token contract\n    IERC20 public immutable ttrustToken;\n\n    // Prediction details\n    MetricPrediction public prediction;\n\n    uint256 public constant PRECISION = 1e18;\n    uint256 public constant RESOLUTION_BUFFER = 2 hours; // Grace period after deadline\n    uint256 public constant MAX_TOLERANCE_PERCENTAGE = 10; // 10% max tolerance for exact values\n\n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n\n    event MetricPredictionCreated(\n        MetricType indexed metricType,\n        ComparisonType indexed comparisonType,\n        uint256 indexed targetValue,\n        uint256 deadline,\n        string description\n    );\n\n    event PredictionResolved(\n        bool indexed targetReached,\n        uint256 actualValue,\n        uint256 targetValue,\n        uint256 resolutionTime\n    );\n\n    event BaselineUpdated(\n        uint256 baselineValue,\n        uint256 baselineTime\n    );\n\n    event EmergencyResolution(\n        bool targetReached,\n        string reason\n    );\n\n    /////////////////\n    /// Modifiers ///\n    /////////////////\n\n    modifier beforeDeadline() {\n        if (block.timestamp >= prediction.deadline) {\n            revert IntuitionMetricsPredictionTTrust__DeadlinePassed();\n        }\n        _;\n    }\n\n    modifier afterDeadline() {\n        if (block.timestamp < prediction.deadline + RESOLUTION_BUFFER) {\n            revert IntuitionMetricsPredictionTTrust__DeadlineNotReached();\n        }\n        _;\n    }\n\n    modifier notResolved() {\n        if (prediction.isResolved) {\n            revert IntuitionMetricsPredictionTTrust__MarketAlreadyResolved();\n        }\n        _;\n    }\n\n    modifier resolved() {\n        if (!prediction.isResolved) {\n            revert IntuitionMetricsPredictionTTrust__MarketNotResolved();\n        }\n        _;\n    }\n\n    //////////////////\n    ////Constructor///\n    //////////////////\n\n    constructor(\n        address _liquidityProvider,\n        address _metricsOracle,\n        address _ttrustToken,\n        MetricType _metricType,\n        ComparisonType _comparisonType,\n        uint256 _targetValue,\n        uint256 _tolerance,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _initialTokenValue,\n        uint8 _initialYesProbability,\n        uint8 _percentageToLock,\n        uint256 _initialTTrustLiquidity\n    ) Ownable(_liquidityProvider) {\n        \n        if (_targetValue == 0) {\n            revert IntuitionMetricsPredictionTTrust__InvalidTargetValue();\n        }\n\n        if (_deadline <= block.timestamp) {\n            revert IntuitionMetricsPredictionTTrust__DeadlinePassed();\n        }\n\n        // Validate tolerance for exact value predictions\n        if (_comparisonType == ComparisonType.EXACT_VALUE) {\n            require(_tolerance <= (_targetValue * MAX_TOLERANCE_PERCENTAGE) / 100, \"Tolerance too high\");\n        }\n\n        // Set oracle and TTrust token\n        metricsOracle = IntuitionMetricsOracle(_metricsOracle);\n        ttrustToken = IERC20(_ttrustToken);\n\n        // Get current baseline value\n        (uint256 currentValue, uint256 currentTime) = _getCurrentMetricValue(_metricType);\n\n        // Store prediction details\n        prediction = MetricPrediction({\n            metricType: _metricType,\n            comparisonType: _comparisonType,\n            targetValue: _targetValue,\n            tolerance: _tolerance,\n            deadline: _deadline,\n            description: _description,\n            isResolved: false,\n            targetReached: false,\n            actualValue: 0,\n            resolutionTime: 0,\n            baselineValue: currentValue,\n            baselineTime: currentTime\n        });\n\n        // Create underlying prediction market with TTrust\n        string memory question = _buildQuestionString(\n            _metricType, \n            _comparisonType, \n            _targetValue, \n            _deadline, \n            _description\n        );\n\n        predictionMarket = new PredictionMarketTTrust(\n            _liquidityProvider,\n            address(this), // This contract acts as oracle\n            _ttrustToken,\n            question,\n            _initialTokenValue,\n            _initialYesProbability,\n            _percentageToLock,\n            _initialTTrustLiquidity\n        );\n\n        emit MetricPredictionCreated(_metricType, _comparisonType, _targetValue, _deadline, _description);\n        emit BaselineUpdated(currentValue, currentTime);\n    }\n\n    /////////////////\n    /// Functions ///\n    /////////////////\n\n    /**\n     * @notice Buy prediction tokens with TTrust (YES = target will be reached, NO = target won't be reached)\n     */\n    function buyTokens(PredictionMarketTTrust.Outcome _outcome, uint256 _amountTokenToBuy) \n        external \n        beforeDeadline\n        notResolved\n    {\n        predictionMarket.buyTokensWithTTrust(_outcome, _amountTokenToBuy);\n    }\n\n    /**\n     * @notice Sell prediction tokens for TTrust\n     */\n    function sellTokens(PredictionMarketTTrust.Outcome _outcome, uint256 _tradingAmount)\n        external\n        beforeDeadline\n        notResolved\n    {\n        predictionMarket.sellTokensForTTrust(_outcome, _tradingAmount);\n    }\n\n    /**\n     * @notice Resolve the prediction by checking current Intuition metrics\n     */\n    function resolvePrediction() external afterDeadline notResolved {\n        \n        // Get current metric value\n        (uint256 currentValue, uint256 timestamp) = _getCurrentMetricValue(prediction.metricType);\n\n        // Check if oracle data is fresh enough\n        if (block.timestamp - timestamp > 4 hours) {\n            revert IntuitionMetricsPredictionTTrust__OracleDataStale();\n        }\n\n        // For growth metrics, calculate growth since baseline\n        uint256 actualValue = currentValue;\n        if (_isGrowthMetric(prediction.metricType)) {\n            actualValue = currentValue > prediction.baselineValue ? \n                currentValue - prediction.baselineValue : 0;\n        }\n\n        // Determine if target was reached\n        bool targetReached = _evaluateTarget(actualValue);\n\n        // Update prediction state\n        prediction.isResolved = true;\n        prediction.targetReached = targetReached;\n        prediction.actualValue = actualValue;\n        prediction.resolutionTime = block.timestamp;\n\n        // Report to underlying prediction market\n        PredictionMarketTTrust.Outcome winningOutcome = targetReached ? \n            PredictionMarketTTrust.Outcome.YES : \n            PredictionMarketTTrust.Outcome.NO;\n            \n        predictionMarket.report(winningOutcome);\n\n        emit PredictionResolved(targetReached, actualValue, prediction.targetValue, block.timestamp);\n    }\n\n    /**\n     * @notice Update baseline for growth metrics (owner only, before deadline)\n     */\n    function updateBaseline() external onlyOwner beforeDeadline notResolved {\n        if (!_isGrowthMetric(prediction.metricType)) {\n            return; // Only applies to growth metrics\n        }\n\n        (uint256 currentValue, uint256 currentTime) = _getCurrentMetricValue(prediction.metricType);\n\n        prediction.baselineValue = currentValue;\n        prediction.baselineTime = currentTime;\n\n        emit BaselineUpdated(currentValue, currentTime);\n    }\n\n    /**\n     * @notice Emergency resolution by owner\n     */\n    function emergencyResolve(bool _targetReached, string memory _reason) \n        external \n        onlyOwner \n        notResolved \n    {\n        prediction.isResolved = true;\n        prediction.targetReached = _targetReached;\n        prediction.resolutionTime = block.timestamp;\n\n        PredictionMarketTTrust.Outcome winningOutcome = _targetReached ? \n            PredictionMarketTTrust.Outcome.YES : \n            PredictionMarketTTrust.Outcome.NO;\n            \n        predictionMarket.report(winningOutcome);\n\n        emit EmergencyResolution(_targetReached, _reason);\n    }\n\n    /**\n     * @notice Redeem winning tokens after resolution\n     */\n    function redeemWinningTokens(uint256 _amount) external resolved {\n        predictionMarket.redeemWinningTokens(_amount);\n    }\n\n    /**\n     * @notice Owner can withdraw profits after resolution\n     */\n    function withdrawProfits() external onlyOwner resolved {\n        predictionMarket.resolveMarketAndWithdraw();\n    }\n\n    /////////////////////////\n    /// Internal Functions //\n    /////////////////////////\n\n    /**\n     * @dev Get current metric value from oracle\n     */\n    function _getCurrentMetricValue(MetricType _metricType) \n        internal \n        view \n        returns (uint256 value, uint256 timestamp) \n    {\n        if (_metricType == MetricType.ATOMS_COUNT || _metricType == MetricType.ATOMS_GROWTH) {\n            return metricsOracle.getMetricCount(IntuitionMetricsOracle.MetricType.ATOMS);\n        } else if (_metricType == MetricType.TRIPLETS_COUNT || _metricType == MetricType.TRIPLETS_GROWTH) {\n            return metricsOracle.getMetricCount(IntuitionMetricsOracle.MetricType.TRIPLETS);\n        } else if (_metricType == MetricType.SIGNALS_COUNT || _metricType == MetricType.SIGNALS_GROWTH) {\n            return metricsOracle.getMetricCount(IntuitionMetricsOracle.MetricType.SIGNALS);\n        } else {\n            revert IntuitionMetricsPredictionTTrust__InvalidMetricType();\n        }\n    }\n\n    /**\n     * @dev Check if metric type is growth-based\n     */\n    function _isGrowthMetric(MetricType _metricType) internal pure returns (bool) {\n        return _metricType == MetricType.ATOMS_GROWTH ||\n               _metricType == MetricType.TRIPLETS_GROWTH ||\n               _metricType == MetricType.SIGNALS_GROWTH;\n    }\n\n    /**\n     * @dev Evaluate if target was reached\n     */\n    function _evaluateTarget(uint256 actualValue) internal view returns (bool) {\n        if (prediction.comparisonType == ComparisonType.ABOVE_THRESHOLD) {\n            return actualValue >= prediction.targetValue;\n        } else if (prediction.comparisonType == ComparisonType.BELOW_THRESHOLD) {\n            return actualValue <= prediction.targetValue;\n        } else { // EXACT_VALUE\n            uint256 diff = actualValue > prediction.targetValue ? \n                actualValue - prediction.targetValue : \n                prediction.targetValue - actualValue;\n            return diff <= prediction.tolerance;\n        }\n    }\n\n    /**\n     * @dev Build human-readable question string\n     */\n    function _buildQuestionString(\n        MetricType _metricType,\n        ComparisonType _comparisonType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _description\n    ) internal pure returns (string memory) {\n        \n        string memory metricName;\n        if (_metricType == MetricType.ATOMS_COUNT) metricName = \"atoms count\";\n        else if (_metricType == MetricType.TRIPLETS_COUNT) metricName = \"triplets count\";\n        else if (_metricType == MetricType.SIGNALS_COUNT) metricName = \"signals count\";\n        else if (_metricType == MetricType.ATOMS_GROWTH) metricName = \"atoms growth\";\n        else if (_metricType == MetricType.TRIPLETS_GROWTH) metricName = \"triplets growth\";\n        else if (_metricType == MetricType.SIGNALS_GROWTH) metricName = \"signals growth\";\n\n        string memory comparisonText;\n        if (_comparisonType == ComparisonType.ABOVE_THRESHOLD) comparisonText = \"exceed\";\n        else if (_comparisonType == ComparisonType.BELOW_THRESHOLD) comparisonText = \"stay below\";\n        else comparisonText = \"equal approximately\";\n\n        return string(abi.encodePacked(\n            \"Will Intuition \", metricName, \" \", comparisonText, \" the target by deadline? \", _description\n        ));\n    }\n\n    /////////////////////////\n    /// View Functions //////\n    /////////////////////////\n\n    /**\n     * @notice Get current Intuition metrics for display\n     */\n    function getCurrentMetrics() \n        external \n        view \n        returns (\n            uint256 currentAtoms,\n            uint256 currentTriplets,\n            uint256 currentSignals,\n            uint256 lastUpdate\n        ) \n    {\n        return metricsOracle.getAllMetrics();\n    }\n\n    /**\n     * @notice Get current prediction target vs actual\n     */\n    function getPredictionProgress()\n        external\n        view\n        returns (\n            uint256 targetValue,\n            uint256 currentValue,\n            uint256 progressPercentage,\n            bool targetReached,\n            uint256 timeRemaining\n        )\n    {\n        targetValue = prediction.targetValue;\n        \n        try this.getCurrentPredictionValue() returns (uint256 current) {\n            currentValue = current;\n            \n            if (prediction.comparisonType == ComparisonType.ABOVE_THRESHOLD) {\n                progressPercentage = targetValue > 0 ? (currentValue * 100) / targetValue : 0;\n                targetReached = currentValue >= targetValue;\n            } else if (prediction.comparisonType == ComparisonType.BELOW_THRESHOLD) {\n                progressPercentage = currentValue <= targetValue ? 100 : 0;\n                targetReached = currentValue <= targetValue;\n            } else { // EXACT_VALUE\n                uint256 diff = currentValue > targetValue ? currentValue - targetValue : targetValue - currentValue;\n                progressPercentage = diff <= prediction.tolerance ? 100 : 0;\n                targetReached = diff <= prediction.tolerance;\n            }\n        } catch {\n            currentValue = 0;\n            progressPercentage = 0;\n            targetReached = false;\n        }\n        \n        timeRemaining = block.timestamp < prediction.deadline ? \n            prediction.deadline - block.timestamp : 0;\n    }\n\n    /**\n     * @notice Get current value for this prediction (handles growth calculations)\n     */\n    function getCurrentPredictionValue() external view returns (uint256) {\n        (uint256 currentValue,) = _getCurrentMetricValue(prediction.metricType);\n        \n        if (_isGrowthMetric(prediction.metricType)) {\n            return currentValue > prediction.baselineValue ? \n                currentValue - prediction.baselineValue : 0;\n        }\n        \n        return currentValue;\n    }\n\n    /**\n     * @notice Get complete prediction information\n     */\n    function getPredictionInfo()\n        external\n        view\n        returns (\n            MetricType metricType,\n            ComparisonType comparisonType,\n            uint256 targetValue,\n            uint256 tolerance,\n            uint256 deadline,\n            string memory description,\n            bool isResolved,\n            bool targetReached,\n            uint256 actualValue,\n            uint256 resolutionTime,\n            address predictionMarketAddress\n        )\n    {\n        return (\n            prediction.metricType,\n            prediction.comparisonType,\n            prediction.targetValue,\n            prediction.tolerance,\n            prediction.deadline,\n            prediction.description,\n            prediction.isResolved,\n            prediction.targetReached,\n            prediction.actualValue,\n            prediction.resolutionTime,\n            address(predictionMarket)\n        );\n    }\n\n    /**\n     * @notice Check if prediction can be resolved\n     */\n    function canResolve() external view returns (bool) {\n        return !prediction.isResolved && \n               block.timestamp >= prediction.deadline + RESOLUTION_BUFFER &&\n               metricsOracle.isMetricValid(_mapToOracleMetricType(prediction.metricType));\n    }\n\n    /**\n     * @dev Map internal metric type to oracle metric type\n     */\n    function _mapToOracleMetricType(MetricType _metricType) \n        internal \n        pure \n        returns (IntuitionMetricsOracle.MetricType) \n    {\n        if (_metricType == MetricType.ATOMS_COUNT || _metricType == MetricType.ATOMS_GROWTH) {\n            return IntuitionMetricsOracle.MetricType.ATOMS;\n        } else if (_metricType == MetricType.TRIPLETS_COUNT || _metricType == MetricType.TRIPLETS_GROWTH) {\n            return IntuitionMetricsOracle.MetricType.TRIPLETS;\n        } else {\n            return IntuitionMetricsOracle.MetricType.SIGNALS;\n        }\n    }\n}"
    },
    "contracts/MockTTrustToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title MockTTrustToken\n * @notice Mock ERC20 token for testing TTrust prediction markets\n * @dev Simple ERC20 implementation with minting capabilities for testing\n */\ncontract MockTTrustToken is IERC20, Ownable {\n    \n    /////////////////\n    /// Events //////\n    /////////////////\n    \n    event Mint(address indexed to, uint256 amount);\n    event Burn(address indexed from, uint256 amount);\n\n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    //////////////////\n    ////Constructor///\n    //////////////////\n\n    constructor(\n        string memory _name,\n        string memory _symbol, \n        uint256 _initialSupply\n    ) Ownable(msg.sender) {\n        name = _name;\n        symbol = _symbol;\n        decimals = 18;\n        totalSupply = _initialSupply;\n        _balances[msg.sender] = _initialSupply;\n        emit Transfer(address(0), msg.sender, _initialSupply);\n    }\n\n    /////////////////\n    /// Functions ///\n    /////////////////\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        address owner = msg.sender;\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external override returns (bool) {\n        address spender = msg.sender;\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Mint new tokens (only owner)\n     */\n    function mint(address to, uint256 amount) external onlyOwner {\n        require(to != address(0), \"MockTTrustToken: mint to the zero address\");\n        \n        totalSupply += amount;\n        unchecked {\n            _balances[to] += amount;\n        }\n        \n        emit Mint(to, amount);\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n     * @notice Burn tokens from sender\n     */\n    function burn(uint256 amount) external {\n        address account = msg.sender;\n        require(_balances[account] >= amount, \"MockTTrustToken: burn amount exceeds balance\");\n        \n        unchecked {\n            _balances[account] -= amount;\n            totalSupply -= amount;\n        }\n        \n        emit Burn(account, amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @notice Airdrop tokens to multiple addresses (testing utility)\n     */\n    function airdrop(address[] calldata recipients, uint256 amount) external onlyOwner {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            if (recipients[i] != address(0)) {\n                totalSupply += amount;\n                unchecked {\n                    _balances[recipients[i]] += amount;\n                }\n                emit Transfer(address(0), recipients[i], amount);\n            }\n        }\n    }\n\n    /////////////////////////\n    /// Internal Functions //\n    /////////////////////////\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(from != address(0), \"MockTTrustToken: transfer from the zero address\");\n        require(to != address(0), \"MockTTrustToken: transfer to the zero address\");\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"MockTTrustToken: transfer amount exceeds balance\");\n        \n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"MockTTrustToken: approve from the zero address\");\n        require(spender != address(0), \"MockTTrustToken: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _spendAllowance(address owner, address spender, uint256 amount) internal {\n        uint256 currentAllowance = _allowances[owner][spender];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"MockTTrustToken: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n}"
    },
    "contracts/PredictionFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { TTrustMarketCapPrediction } from \"./TTrustMarketCapPrediction.sol\";\nimport { IntuitionMetricsPrediction } from \"./IntuitionMetricsPrediction.sol\";\nimport { TTrustPriceOracle } from \"./TTrustPriceOracle.sol\";\nimport { IntuitionMetricsOracle } from \"./IntuitionMetricsOracle.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title PredictionFactory\n * @notice Factory contract for creating different types of prediction markets\n * @dev Manages creation and registry of TTrust and Intuition metrics prediction markets\n */\ncontract PredictionFactory is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error PredictionFactory__OracleNotSet();\n    error PredictionFactory__InvalidInitialValue();\n    error PredictionFactory__InvalidProbability();\n    error PredictionFactory__InvalidDeadline();\n    error PredictionFactory__InsufficientLiquidity();\n    error PredictionFactory__InvalidTargetValue();\n    error PredictionFactory__MarketCreationFailed();\n    \n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n    \n    enum MarketType {\n        TTRUST_MARKET_CAP,\n        TTRUST_PRICE,\n        INTUITION_METRICS\n    }\n    \n    struct MarketInfo {\n        MarketType marketType;\n        address marketAddress;\n        address creator;\n        uint256 creationTime;\n        uint256 deadline;\n        string description;\n        bool isActive;\n    }\n    \n    // Oracles\n    TTrustPriceOracle public ttustPriceOracle;\n    IntuitionMetricsOracle public intuitionMetricsOracle;\n    \n    // Market registry\n    address[] public allMarkets;\n    mapping(address => MarketInfo) public marketInfo;\n    mapping(address => address[]) public creatorMarkets; // creator => market addresses\n    mapping(MarketType => address[]) public marketsByType;\n    \n    // Default settings for market creation\n    uint256 public defaultInitialTokenValue = 1e16; // 0.01 ETH per token\n    uint8 public defaultInitialProbability = 50; // 50% initial probability\n    uint8 public defaultPercentageLocked = 20; // 20% locked initially\n    uint256 public minimumLiquidity = 1e17; // 0.1 ETH minimum\n    uint256 public creationFee = 1e15; // 0.001 ETH creation fee\n    \n    // Factory settings\n    bool public factoryPaused = false;\n    \n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n    \n    event TTrustMarketCreated(\n        address indexed marketAddress,\n        address indexed creator,\n        TTrustMarketCapPrediction.PredictionType indexed predictionType,\n        uint256 targetValue,\n        uint256 deadline,\n        string description\n    );\n    \n    event IntuitionMetricsMarketCreated(\n        address indexed marketAddress,\n        address indexed creator,\n        IntuitionMetricsPrediction.MetricType indexed metricType,\n        IntuitionMetricsPrediction.ComparisonType comparisonType,\n        uint256 targetValue,\n        uint256 deadline,\n        string description\n    );\n    \n    event OracleUpdated(\n        string indexed oracleType,\n        address indexed oldOracle,\n        address indexed newOracle\n    );\n    \n    event DefaultSettingsUpdated(\n        uint256 initialTokenValue,\n        uint8 initialProbability,\n        uint8 percentageLocked\n    );\n    \n    event FactoryPausedToggled(bool paused);\n    event CreationFeeUpdated(uint256 newFee);\n    event MinimumLiquidityUpdated(uint256 newMinimum);\n    \n    /////////////////\n    /// Modifiers ///\n    /////////////////\n    \n    modifier whenNotPaused() {\n        require(!factoryPaused, \"Factory is paused\");\n        _;\n    }\n    \n    modifier validLiquidity() {\n        if (msg.value < minimumLiquidity + creationFee) {\n            revert PredictionFactory__InsufficientLiquidity();\n        }\n        _;\n    }\n    \n    modifier validDeadline(uint256 _deadline) {\n        if (_deadline <= block.timestamp + 1 hours) {\n            revert PredictionFactory__InvalidDeadline();\n        }\n        _;\n    }\n    \n    //////////////////\n    ////Constructor///\n    //////////////////\n    \n    constructor(\n        address _owner,\n        address _ttustPriceOracle,\n        address _intuitionMetricsOracle\n    ) Ownable(_owner) {\n        if (_ttustPriceOracle != address(0)) {\n            ttustPriceOracle = TTrustPriceOracle(_ttustPriceOracle);\n        }\n        if (_intuitionMetricsOracle != address(0)) {\n            intuitionMetricsOracle = IntuitionMetricsOracle(_intuitionMetricsOracle);\n        }\n    }\n    \n    /////////////////\n    /// Functions ///\n    /////////////////\n    \n    /**\n     * @notice Create a new TTrust market cap prediction market\n     * @param _predictionType Type of TTrust prediction (market cap above/below, price above/below)\n     * @param _targetValue Target market cap or price value (18 decimals)\n     * @param _deadline When prediction expires\n     * @param _description Human readable description\n     * @param _customTokenValue Custom initial token value (0 to use default)\n     * @param _customProbability Custom initial probability (0 to use default)\n     * @return marketAddress Address of created market\n     */\n    function createTTrustMarket(\n        TTrustMarketCapPrediction.PredictionType _predictionType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _customTokenValue,\n        uint8 _customProbability\n    ) \n        external \n        payable \n        whenNotPaused\n        validLiquidity\n        validDeadline(_deadline)\n        returns (address marketAddress)\n    {\n        if (address(ttustPriceOracle) == address(0)) {\n            revert PredictionFactory__OracleNotSet();\n        }\n        \n        if (_targetValue == 0) {\n            revert PredictionFactory__InvalidTargetValue();\n        }\n        \n        // Use custom values or defaults\n        uint256 tokenValue = _customTokenValue > 0 ? _customTokenValue : defaultInitialTokenValue;\n        uint8 probability = _customProbability > 0 ? _customProbability : defaultInitialProbability;\n        \n        // Validate probability\n        if (probability >= 100) {\n            revert PredictionFactory__InvalidProbability();\n        }\n        \n        // Calculate liquidity (total value minus creation fee)\n        uint256 liquidityAmount = msg.value - creationFee;\n        \n        try new TTrustMarketCapPrediction{value: liquidityAmount}(\n            msg.sender,\n            address(ttustPriceOracle),\n            _predictionType,\n            _targetValue,\n            _deadline,\n            _description,\n            tokenValue,\n            probability,\n            defaultPercentageLocked\n        ) returns (TTrustMarketCapPrediction market) {\n            marketAddress = address(market);\n        } catch {\n            revert PredictionFactory__MarketCreationFailed();\n        }\n        \n        // Register market\n        _registerMarket(\n            marketAddress,\n            MarketType.TTRUST_MARKET_CAP,\n            msg.sender,\n            _deadline,\n            _description\n        );\n        \n        emit TTrustMarketCreated(\n            marketAddress,\n            msg.sender,\n            _predictionType,\n            _targetValue,\n            _deadline,\n            _description\n        );\n    }\n    \n    /**\n     * @notice Create a new Intuition metrics prediction market\n     * @param _metricType Type of metric (atoms, triplets, signals, or growth)\n     * @param _comparisonType How to compare (above, below, exact)\n     * @param _targetValue Target metric value\n     * @param _tolerance Tolerance for exact comparisons\n     * @param _deadline When prediction expires\n     * @param _description Human readable description\n     * @return marketAddress Address of created market\n     */\n    function createIntuitionMetricsMarket(\n        IntuitionMetricsPrediction.MetricType _metricType,\n        IntuitionMetricsPrediction.ComparisonType _comparisonType,\n        uint256 _targetValue,\n        uint256 _tolerance,\n        uint256 _deadline,\n        string memory _description\n    )\n        external\n        payable\n        whenNotPaused\n        validLiquidity\n        validDeadline(_deadline)\n        returns (address marketAddress)\n    {\n        if (address(intuitionMetricsOracle) == address(0)) {\n            revert PredictionFactory__OracleNotSet();\n        }\n        \n        if (_targetValue == 0) {\n            revert PredictionFactory__InvalidTargetValue();\n        }\n        \n        // Calculate liquidity\n        uint256 liquidityAmount = msg.value - creationFee;\n        \n        try new IntuitionMetricsPrediction{value: liquidityAmount}(\n            msg.sender,\n            address(intuitionMetricsOracle),\n            _metricType,\n            _comparisonType,\n            _targetValue,\n            _tolerance,\n            _deadline,\n            _description,\n            defaultInitialTokenValue,\n            defaultInitialProbability,\n            defaultPercentageLocked\n        ) returns (IntuitionMetricsPrediction market) {\n            marketAddress = address(market);\n        } catch {\n            revert PredictionFactory__MarketCreationFailed();\n        }\n        \n        // Register market\n        _registerMarket(\n            marketAddress,\n            MarketType.INTUITION_METRICS,\n            msg.sender,\n            _deadline,\n            _description\n        );\n        \n        emit IntuitionMetricsMarketCreated(\n            marketAddress,\n            msg.sender,\n            _metricType,\n            _comparisonType,\n            _targetValue,\n            _deadline,\n            _description\n        );\n    }\n    \n    /////////////////////////\n    /// Internal Functions //\n    /////////////////////////\n    \n    /**\n     * @dev Register a newly created market\n     */\n    function _registerMarket(\n        address _marketAddress,\n        MarketType _marketType,\n        address _creator,\n        uint256 _deadline,\n        string memory _description\n    ) internal {\n        allMarkets.push(_marketAddress);\n        \n        marketInfo[_marketAddress] = MarketInfo({\n            marketType: _marketType,\n            marketAddress: _marketAddress,\n            creator: _creator,\n            creationTime: block.timestamp,\n            deadline: _deadline,\n            description: _description,\n            isActive: true\n        });\n        \n        creatorMarkets[_creator].push(_marketAddress);\n        marketsByType[_marketType].push(_marketAddress);\n    }\n    \n    /////////////////////////\n    /// Admin Functions ////\n    /////////////////////////\n    \n    /**\n     * @notice Set TTrust price oracle address\n     */\n    function setTTrustPriceOracle(address _oracle) external onlyOwner {\n        address oldOracle = address(ttustPriceOracle);\n        ttustPriceOracle = TTrustPriceOracle(_oracle);\n        emit OracleUpdated(\"TTrust\", oldOracle, _oracle);\n    }\n    \n    /**\n     * @notice Set Intuition metrics oracle address\n     */\n    function setIntuitionMetricsOracle(address _oracle) external onlyOwner {\n        address oldOracle = address(intuitionMetricsOracle);\n        intuitionMetricsOracle = IntuitionMetricsOracle(_oracle);\n        emit OracleUpdated(\"Intuition\", oldOracle, _oracle);\n    }\n    \n    /**\n     * @notice Update default market creation settings\n     */\n    function setDefaultSettings(\n        uint256 _initialTokenValue,\n        uint8 _initialProbability,\n        uint8 _percentageLocked\n    ) external onlyOwner {\n        if (_initialProbability >= 100 || _percentageLocked >= 100) {\n            revert PredictionFactory__InvalidProbability();\n        }\n        \n        defaultInitialTokenValue = _initialTokenValue;\n        defaultInitialProbability = _initialProbability;\n        defaultPercentageLocked = _percentageLocked;\n        \n        emit DefaultSettingsUpdated(_initialTokenValue, _initialProbability, _percentageLocked);\n    }\n    \n    /**\n     * @notice Set creation fee\n     */\n    function setCreationFee(uint256 _fee) external onlyOwner {\n        creationFee = _fee;\n        emit CreationFeeUpdated(_fee);\n    }\n    \n    /**\n     * @notice Set minimum liquidity requirement\n     */\n    function setMinimumLiquidity(uint256 _minimum) external onlyOwner {\n        minimumLiquidity = _minimum;\n        emit MinimumLiquidityUpdated(_minimum);\n    }\n    \n    /**\n     * @notice Pause/unpause factory\n     */\n    function toggleFactoryPause() external onlyOwner {\n        factoryPaused = !factoryPaused;\n        emit FactoryPausedToggled(factoryPaused);\n    }\n    \n    /**\n     * @notice Withdraw accumulated creation fees\n     */\n    function withdrawFees() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No fees to withdraw\");\n        \n        (bool success,) = owner().call{value: balance}(\"\");\n        require(success, \"Fee withdrawal failed\");\n    }\n    \n    /**\n     * @notice Mark a market as inactive (for cleanup)\n     */\n    function deactivateMarket(address _market) external onlyOwner {\n        require(marketInfo[_market].marketAddress != address(0), \"Market not found\");\n        marketInfo[_market].isActive = false;\n    }\n    \n    /////////////////////////\n    /// View Functions //////\n    /////////////////////////\n    \n    /**\n     * @notice Get total number of markets created\n     */\n    function getTotalMarketsCount() external view returns (uint256) {\n        return allMarkets.length;\n    }\n    \n    /**\n     * @notice Get markets by type\n     */\n    function getMarketsByType(MarketType _marketType) external view returns (address[] memory) {\n        return marketsByType[_marketType];\n    }\n    \n    /**\n     * @notice Get markets created by a specific address\n     */\n    function getCreatorMarkets(address _creator) external view returns (address[] memory) {\n        return creatorMarkets[_creator];\n    }\n    \n    /**\n     * @notice Get active markets (paginated)\n     */\n    function getActiveMarkets(uint256 _offset, uint256 _limit) \n        external \n        view \n        returns (address[] memory markets, uint256 total) \n    {\n        uint256 activeCount = 0;\n        \n        // Count active markets\n        for (uint256 i = 0; i < allMarkets.length; i++) {\n            if (marketInfo[allMarkets[i]].isActive) {\n                activeCount++;\n            }\n        }\n        \n        total = activeCount;\n        \n        if (_offset >= activeCount) {\n            return (new address[](0), total);\n        }\n        \n        uint256 end = _offset + _limit;\n        if (end > activeCount) {\n            end = activeCount;\n        }\n        \n        markets = new address[](end - _offset);\n        uint256 activeIndex = 0;\n        uint256 resultIndex = 0;\n        \n        for (uint256 i = 0; i < allMarkets.length && resultIndex < markets.length; i++) {\n            if (marketInfo[allMarkets[i]].isActive) {\n                if (activeIndex >= _offset) {\n                    markets[resultIndex] = allMarkets[i];\n                    resultIndex++;\n                }\n                activeIndex++;\n            }\n        }\n    }\n    \n    /**\n     * @notice Get market details\n     */\n    function getMarketDetails(address _market) \n        external \n        view \n        returns (\n            MarketType marketType,\n            address creator,\n            uint256 creationTime,\n            uint256 deadline,\n            string memory description,\n            bool isActive,\n            bool isExpired\n        ) \n    {\n        MarketInfo memory info = marketInfo[_market];\n        return (\n            info.marketType,\n            info.creator,\n            info.creationTime,\n            info.deadline,\n            info.description,\n            info.isActive,\n            block.timestamp > info.deadline\n        );\n    }\n    \n    /**\n     * @notice Get factory statistics\n     */\n    function getFactoryStats()\n        external\n        view\n        returns (\n            uint256 totalMarkets,\n            uint256 activeMarkets,\n            uint256 ttustMarkets,\n            uint256 metricsMarkets,\n            uint256 totalFeesCollected\n        )\n    {\n        totalMarkets = allMarkets.length;\n        ttustMarkets = marketsByType[MarketType.TTRUST_MARKET_CAP].length;\n        metricsMarkets = marketsByType[MarketType.INTUITION_METRICS].length;\n        totalFeesCollected = address(this).balance;\n        \n        for (uint256 i = 0; i < allMarkets.length; i++) {\n            if (marketInfo[allMarkets[i]].isActive) {\n                activeMarkets++;\n            }\n        }\n    }\n}"
    },
    "contracts/PredictionFactoryTTrust.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { TTrustMarketCapPredictionTTrust } from \"./TTrustMarketCapPredictionTTrust.sol\";\nimport { IntuitionMetricsPredictionTTrust } from \"./IntuitionMetricsPredictionTTrust.sol\";\nimport { TTrustPriceOracle } from \"./TTrustPriceOracle.sol\";\nimport { IntuitionMetricsOracle } from \"./IntuitionMetricsOracle.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title PredictionFactoryTTrust\n * @notice Factory contract for creating TTrust-based prediction markets\n * @dev Manages creation and registry of TTrust and Intuition metrics prediction markets using TTrust currency\n */\ncontract PredictionFactoryTTrust is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error PredictionFactoryTTrust__OracleNotSet();\n    error PredictionFactoryTTrust__InvalidInitialValue();\n    error PredictionFactoryTTrust__InvalidProbability();\n    error PredictionFactoryTTrust__InvalidDeadline();\n    error PredictionFactoryTTrust__InsufficientLiquidity();\n    error PredictionFactoryTTrust__InvalidTargetValue();\n    error PredictionFactoryTTrust__MarketCreationFailed();\n    error PredictionFactoryTTrust__TTrustTransferFailed();\n    error PredictionFactoryTTrust__InsufficientTTrustAllowance();\n    \n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n    \n    enum MarketType {\n        TTRUST_MARKET_CAP,\n        TTRUST_PRICE,\n        INTUITION_METRICS\n    }\n    \n    struct MarketInfo {\n        MarketType marketType;\n        address marketAddress;\n        address creator;\n        uint256 creationTime;\n        uint256 deadline;\n        string description;\n        bool isActive;\n    }\n    \n    // TTrust token contract\n    IERC20 public immutable ttrustToken;\n    \n    // Oracles\n    TTrustPriceOracle public ttustPriceOracle;\n    IntuitionMetricsOracle public intuitionMetricsOracle;\n    \n    // Market registry\n    address[] public allMarkets;\n    mapping(address => MarketInfo) public marketInfo;\n    mapping(address => address[]) public creatorMarkets; // creator => market addresses\n    mapping(MarketType => address[]) public marketsByType;\n    \n    // Default settings for market creation (all in TTrust now)\n    uint256 public defaultInitialTokenValue = 1e16; // 0.01 TTrust per token\n    uint8 public defaultInitialProbability = 50; // 50% initial probability\n    uint8 public defaultPercentageLocked = 20; // 20% locked initially\n    uint256 public minimumLiquidity = 1e17; // 0.1 TTrust minimum\n    uint256 public creationFee = 1e15; // 0.001 TTrust creation fee\n    \n    // Factory settings\n    bool public factoryPaused = false;\n    \n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n    \n    event TTrustMarketCreated(\n        address indexed marketAddress,\n        address indexed creator,\n        TTrustMarketCapPredictionTTrust.PredictionType indexed predictionType,\n        uint256 targetValue,\n        uint256 deadline,\n        string description\n    );\n    \n    event IntuitionMetricsMarketCreated(\n        address indexed marketAddress,\n        address indexed creator,\n        IntuitionMetricsPredictionTTrust.MetricType indexed metricType,\n        IntuitionMetricsPredictionTTrust.ComparisonType comparisonType,\n        uint256 targetValue,\n        uint256 deadline,\n        string description\n    );\n    \n    event OracleUpdated(\n        string indexed oracleType,\n        address indexed oldOracle,\n        address indexed newOracle\n    );\n    \n    event DefaultSettingsUpdated(\n        uint256 initialTokenValue,\n        uint8 initialProbability,\n        uint8 percentageLocked\n    );\n    \n    event FactoryPausedToggled(bool paused);\n    event CreationFeeUpdated(uint256 newFee);\n    event MinimumLiquidityUpdated(uint256 newMinimum);\n    \n    /////////////////\n    /// Modifiers ///\n    /////////////////\n    \n    modifier whenNotPaused() {\n        require(!factoryPaused, \"Factory is paused\");\n        _;\n    }\n    \n    modifier validLiquidity(uint256 _totalTTrustNeeded) {\n        if (_totalTTrustNeeded < minimumLiquidity + creationFee) {\n            revert PredictionFactoryTTrust__InsufficientLiquidity();\n        }\n        _;\n    }\n    \n    modifier validDeadline(uint256 _deadline) {\n        if (_deadline <= block.timestamp + 1 hours) {\n            revert PredictionFactoryTTrust__InvalidDeadline();\n        }\n        _;\n    }\n    \n    //////////////////\n    ////Constructor///\n    //////////////////\n    \n    constructor(\n        address _owner,\n        address _ttrustToken,\n        address _ttustPriceOracle,\n        address _intuitionMetricsOracle\n    ) Ownable(_owner) {\n        ttrustToken = IERC20(_ttrustToken);\n        \n        if (_ttustPriceOracle != address(0)) {\n            ttustPriceOracle = TTrustPriceOracle(_ttustPriceOracle);\n        }\n        if (_intuitionMetricsOracle != address(0)) {\n            intuitionMetricsOracle = IntuitionMetricsOracle(_intuitionMetricsOracle);\n        }\n    }\n    \n    /////////////////\n    /// Functions ///\n    /////////////////\n    \n    /**\n     * @notice Create a new TTrust market cap prediction market\n     * @param _predictionType Type of TTrust prediction\n     * @param _targetValue Target market cap or price value (18 decimals)\n     * @param _deadline When prediction expires\n     * @param _description Human readable description\n     * @param _customTokenValue Custom initial token value (0 to use default)\n     * @param _customProbability Custom initial probability (0 to use default)\n     * @param _liquidityAmount TTrust amount for initial liquidity\n     * @return marketAddress Address of created market\n     */\n    function createTTrustMarket(\n        TTrustMarketCapPredictionTTrust.PredictionType _predictionType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _customTokenValue,\n        uint8 _customProbability,\n        uint256 _liquidityAmount\n    ) \n        external \n        whenNotPaused\n        validLiquidity(_liquidityAmount)\n        validDeadline(_deadline)\n        returns (address marketAddress)\n    {\n        if (address(ttustPriceOracle) == address(0)) {\n            revert PredictionFactoryTTrust__OracleNotSet();\n        }\n        \n        if (_targetValue == 0) {\n            revert PredictionFactoryTTrust__InvalidTargetValue();\n        }\n        \n        // Use custom values or defaults\n        uint256 tokenValue = _customTokenValue > 0 ? _customTokenValue : defaultInitialTokenValue;\n        uint8 probability = _customProbability > 0 ? _customProbability : defaultInitialProbability;\n        \n        // Validate probability\n        if (probability >= 100) {\n            revert PredictionFactoryTTrust__InvalidProbability();\n        }\n        \n        // Calculate liquidity (total amount minus creation fee)\n        uint256 actualLiquidity = _liquidityAmount - creationFee;\n        \n        // Check TTrust allowance\n        uint256 allowance = ttrustToken.allowance(msg.sender, address(this));\n        if (allowance < _liquidityAmount) {\n            revert PredictionFactoryTTrust__InsufficientTTrustAllowance();\n        }\n        \n        // Transfer TTrust from user (creation fee + liquidity)\n        bool success = ttrustToken.transferFrom(msg.sender, address(this), _liquidityAmount);\n        if (!success) {\n            revert PredictionFactoryTTrust__TTrustTransferFailed();\n        }\n        \n        // Approve liquidity for the new market\n        ttrustToken.approve(address(this), actualLiquidity);\n        \n        try new TTrustMarketCapPredictionTTrust(\n            msg.sender,\n            address(ttustPriceOracle),\n            address(ttrustToken),\n            _predictionType,\n            _targetValue,\n            _deadline,\n            _description,\n            tokenValue,\n            probability,\n            defaultPercentageLocked,\n            actualLiquidity\n        ) returns (TTrustMarketCapPredictionTTrust market) {\n            marketAddress = address(market);\n        } catch {\n            revert PredictionFactoryTTrust__MarketCreationFailed();\n        }\n        \n        // Register market\n        _registerMarket(\n            marketAddress,\n            MarketType.TTRUST_MARKET_CAP,\n            msg.sender,\n            _deadline,\n            _description\n        );\n        \n        emit TTrustMarketCreated(\n            marketAddress,\n            msg.sender,\n            _predictionType,\n            _targetValue,\n            _deadline,\n            _description\n        );\n    }\n    \n    /**\n     * @notice Create a new Intuition metrics prediction market\n     * @param _metricType Type of metric (atoms, triplets, signals, or growth)\n     * @param _comparisonType How to compare (above, below, exact)\n     * @param _targetValue Target metric value\n     * @param _tolerance Tolerance for exact comparisons\n     * @param _deadline When prediction expires\n     * @param _description Human readable description\n     * @param _liquidityAmount TTrust amount for initial liquidity\n     * @return marketAddress Address of created market\n     */\n    function createIntuitionMetricsMarket(\n        IntuitionMetricsPredictionTTrust.MetricType _metricType,\n        IntuitionMetricsPredictionTTrust.ComparisonType _comparisonType,\n        uint256 _targetValue,\n        uint256 _tolerance,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _liquidityAmount\n    )\n        external\n        whenNotPaused\n        validLiquidity(_liquidityAmount)\n        validDeadline(_deadline)\n        returns (address marketAddress)\n    {\n        if (address(intuitionMetricsOracle) == address(0)) {\n            revert PredictionFactoryTTrust__OracleNotSet();\n        }\n        \n        if (_targetValue == 0) {\n            revert PredictionFactoryTTrust__InvalidTargetValue();\n        }\n        \n        // Calculate liquidity\n        uint256 actualLiquidity = _liquidityAmount - creationFee;\n        \n        // Check TTrust allowance\n        uint256 allowance = ttrustToken.allowance(msg.sender, address(this));\n        if (allowance < _liquidityAmount) {\n            revert PredictionFactoryTTrust__InsufficientTTrustAllowance();\n        }\n        \n        // Transfer TTrust from user\n        bool success = ttrustToken.transferFrom(msg.sender, address(this), _liquidityAmount);\n        if (!success) {\n            revert PredictionFactoryTTrust__TTrustTransferFailed();\n        }\n        \n        // Approve liquidity for the new market\n        ttrustToken.approve(address(this), actualLiquidity);\n        \n        try new IntuitionMetricsPredictionTTrust(\n            msg.sender,\n            address(intuitionMetricsOracle),\n            address(ttrustToken),\n            _metricType,\n            _comparisonType,\n            _targetValue,\n            _tolerance,\n            _deadline,\n            _description,\n            defaultInitialTokenValue,\n            defaultInitialProbability,\n            defaultPercentageLocked,\n            actualLiquidity\n        ) returns (IntuitionMetricsPredictionTTrust market) {\n            marketAddress = address(market);\n        } catch {\n            revert PredictionFactoryTTrust__MarketCreationFailed();\n        }\n        \n        // Register market\n        _registerMarket(\n            marketAddress,\n            MarketType.INTUITION_METRICS,\n            msg.sender,\n            _deadline,\n            _description\n        );\n        \n        emit IntuitionMetricsMarketCreated(\n            marketAddress,\n            msg.sender,\n            _metricType,\n            _comparisonType,\n            _targetValue,\n            _deadline,\n            _description\n        );\n    }\n    \n    /////////////////////////\n    /// Internal Functions //\n    /////////////////////////\n    \n    /**\n     * @dev Register a newly created market\n     */\n    function _registerMarket(\n        address _marketAddress,\n        MarketType _marketType,\n        address _creator,\n        uint256 _deadline,\n        string memory _description\n    ) internal {\n        allMarkets.push(_marketAddress);\n        \n        marketInfo[_marketAddress] = MarketInfo({\n            marketType: _marketType,\n            marketAddress: _marketAddress,\n            creator: _creator,\n            creationTime: block.timestamp,\n            deadline: _deadline,\n            description: _description,\n            isActive: true\n        });\n        \n        creatorMarkets[_creator].push(_marketAddress);\n        marketsByType[_marketType].push(_marketAddress);\n    }\n    \n    /////////////////////////\n    /// Admin Functions ////\n    /////////////////////////\n    \n    /**\n     * @notice Set TTrust price oracle address\n     */\n    function setTTrustPriceOracle(address _oracle) external onlyOwner {\n        address oldOracle = address(ttustPriceOracle);\n        ttustPriceOracle = TTrustPriceOracle(_oracle);\n        emit OracleUpdated(\"TTrust\", oldOracle, _oracle);\n    }\n    \n    /**\n     * @notice Set Intuition metrics oracle address\n     */\n    function setIntuitionMetricsOracle(address _oracle) external onlyOwner {\n        address oldOracle = address(intuitionMetricsOracle);\n        intuitionMetricsOracle = IntuitionMetricsOracle(_oracle);\n        emit OracleUpdated(\"Intuition\", oldOracle, _oracle);\n    }\n    \n    /**\n     * @notice Update default market creation settings\n     */\n    function setDefaultSettings(\n        uint256 _initialTokenValue,\n        uint8 _initialProbability,\n        uint8 _percentageLocked\n    ) external onlyOwner {\n        if (_initialProbability >= 100 || _percentageLocked >= 100) {\n            revert PredictionFactoryTTrust__InvalidProbability();\n        }\n        \n        defaultInitialTokenValue = _initialTokenValue;\n        defaultInitialProbability = _initialProbability;\n        defaultPercentageLocked = _percentageLocked;\n        \n        emit DefaultSettingsUpdated(_initialTokenValue, _initialProbability, _percentageLocked);\n    }\n    \n    /**\n     * @notice Set creation fee in TTrust\n     */\n    function setCreationFee(uint256 _fee) external onlyOwner {\n        creationFee = _fee;\n        emit CreationFeeUpdated(_fee);\n    }\n    \n    /**\n     * @notice Set minimum liquidity requirement in TTrust\n     */\n    function setMinimumLiquidity(uint256 _minimum) external onlyOwner {\n        minimumLiquidity = _minimum;\n        emit MinimumLiquidityUpdated(_minimum);\n    }\n    \n    /**\n     * @notice Pause/unpause factory\n     */\n    function toggleFactoryPause() external onlyOwner {\n        factoryPaused = !factoryPaused;\n        emit FactoryPausedToggled(factoryPaused);\n    }\n    \n    /**\n     * @notice Withdraw accumulated TTrust creation fees\n     */\n    function withdrawFees() external onlyOwner {\n        uint256 balance = ttrustToken.balanceOf(address(this));\n        require(balance > 0, \"No fees to withdraw\");\n        \n        bool success = ttrustToken.transfer(owner(), balance);\n        require(success, \"Fee withdrawal failed\");\n    }\n    \n    /**\n     * @notice Mark a market as inactive (for cleanup)\n     */\n    function deactivateMarket(address _market) external onlyOwner {\n        require(marketInfo[_market].marketAddress != address(0), \"Market not found\");\n        marketInfo[_market].isActive = false;\n    }\n    \n    /////////////////////////\n    /// View Functions //////\n    /////////////////////////\n    \n    /**\n     * @notice Get total number of markets created\n     */\n    function getTotalMarketsCount() external view returns (uint256) {\n        return allMarkets.length;\n    }\n    \n    /**\n     * @notice Get markets by type\n     */\n    function getMarketsByType(MarketType _marketType) external view returns (address[] memory) {\n        return marketsByType[_marketType];\n    }\n    \n    /**\n     * @notice Get markets created by a specific address\n     */\n    function getCreatorMarkets(address _creator) external view returns (address[] memory) {\n        return creatorMarkets[_creator];\n    }\n    \n    /**\n     * @notice Get active markets (paginated)\n     */\n    function getActiveMarkets(uint256 _offset, uint256 _limit) \n        external \n        view \n        returns (address[] memory markets, uint256 total) \n    {\n        uint256 activeCount = 0;\n        \n        // Count active markets\n        for (uint256 i = 0; i < allMarkets.length; i++) {\n            if (marketInfo[allMarkets[i]].isActive) {\n                activeCount++;\n            }\n        }\n        \n        total = activeCount;\n        \n        if (_offset >= activeCount) {\n            return (new address[](0), total);\n        }\n        \n        uint256 end = _offset + _limit;\n        if (end > activeCount) {\n            end = activeCount;\n        }\n        \n        markets = new address[](end - _offset);\n        uint256 activeIndex = 0;\n        uint256 resultIndex = 0;\n        \n        for (uint256 i = 0; i < allMarkets.length && resultIndex < markets.length; i++) {\n            if (marketInfo[allMarkets[i]].isActive) {\n                if (activeIndex >= _offset) {\n                    markets[resultIndex] = allMarkets[i];\n                    resultIndex++;\n                }\n                activeIndex++;\n            }\n        }\n    }\n    \n    /**\n     * @notice Get market details\n     */\n    function getMarketDetails(address _market) \n        external \n        view \n        returns (\n            MarketType marketType,\n            address creator,\n            uint256 creationTime,\n            uint256 deadline,\n            string memory description,\n            bool isActive,\n            bool isExpired\n        ) \n    {\n        MarketInfo memory info = marketInfo[_market];\n        return (\n            info.marketType,\n            info.creator,\n            info.creationTime,\n            info.deadline,\n            info.description,\n            info.isActive,\n            block.timestamp > info.deadline\n        );\n    }\n    \n    /**\n     * @notice Get factory statistics\n     */\n    function getFactoryStats()\n        external\n        view\n        returns (\n            uint256 totalMarkets,\n            uint256 activeMarkets,\n            uint256 ttustMarkets,\n            uint256 metricsMarkets,\n            uint256 totalFeesCollected\n        )\n    {\n        totalMarkets = allMarkets.length;\n        ttustMarkets = marketsByType[MarketType.TTRUST_MARKET_CAP].length;\n        metricsMarkets = marketsByType[MarketType.INTUITION_METRICS].length;\n        totalFeesCollected = ttrustToken.balanceOf(address(this));\n        \n        for (uint256 i = 0; i < allMarkets.length; i++) {\n            if (marketInfo[allMarkets[i]].isActive) {\n                activeMarkets++;\n            }\n        }\n    }\n    \n    /**\n     * @notice Get TTrust token address\n     */\n    function getTTrustToken() external view returns (address) {\n        return address(ttrustToken);\n    }\n}"
    },
    "contracts/PredictionMarket.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { PredictionMarketToken } from \"./PredictionMarketToken.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PredictionMarket is Ownable {\n    /////////////////\n    /// Errors //////\n    /////////////////\n\n    error PredictionMarket__MustProvideETHForInitialLiquidity();\n    error PredictionMarket__InvalidProbability();\n    error PredictionMarket__PredictionAlreadyReported();\n    error PredictionMarket__OnlyOracleCanReport();\n    error PredictionMarket__OwnerCannotCall();\n    error PredictionMarket__PredictionNotReported();\n    error PredictionMarket__InsufficientWinningTokens();\n    error PredictionMarket__AmountMustBeGreaterThanZero();\n    error PredictionMarket__MustSendExactETHAmount();\n    error PredictionMarket__InsufficientTokenReserve(Outcome _outcome, uint256 _amountToken);\n    error PredictionMarket__TokenTransferFailed();\n    error PredictionMarket__ETHTransferFailed();\n    error PredictionMarket__InsufficientBalance(uint256 _tradingAmount, uint256 _userBalance);\n    error PredictionMarket__InsufficientAllowance(uint256 _tradingAmount, uint256 _allowance);\n    error PredictionMarket__InsufficientLiquidity();\n    error PredictionMarket__InvalidPercentageToLock();\n\n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n\n    enum Outcome {\n        YES,\n        NO\n    }\n\n    uint256 private constant PRECISION = 1e18;\n\n    /// Checkpoint 2 ///\n    address public immutable i_oracle;\n    uint256 public immutable i_initialTokenValue;\n    uint256 public immutable i_percentageLocked;\n    uint256 public immutable i_initialYesProbability;\n\n    string public s_question;\n    uint256 public s_ethCollateral;\n    uint256 public s_lpTradingRevenue;\n\n    /// Checkpoint 3 ///\n    PredictionMarketToken public immutable i_yesToken;\n    PredictionMarketToken public immutable i_noToken;\n\n    /// Checkpoint 5 ///\n    PredictionMarketToken public s_winningToken;\n    bool public s_isReported;\n\n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n\n    event TokensPurchased(address indexed buyer, Outcome outcome, uint256 amount, uint256 ethAmount);\n    event TokensSold(address indexed seller, Outcome outcome, uint256 amount, uint256 ethAmount);\n    event WinningTokensRedeemed(address indexed redeemer, uint256 amount, uint256 ethAmount);\n    event MarketReported(address indexed oracle, Outcome winningOutcome, address winningToken);\n    event MarketResolved(address indexed resolver, uint256 totalEthToSend);\n    event LiquidityAdded(address indexed provider, uint256 ethAmount, uint256 tokensAmount);\n    event LiquidityRemoved(address indexed provider, uint256 ethAmount, uint256 tokensAmount);\n\n    /////////////////\n    /// Modifiers ///\n    /////////////////\n\n    /// Checkpoint 5 ///\n    modifier predictionNotReported() {\n        if (s_isReported) {\n            revert PredictionMarket__PredictionAlreadyReported();\n        }\n        _;\n    }\n\n    /// Checkpoint 6 ///\n    modifier predictionReported() {\n        if (!s_isReported) {\n            revert PredictionMarket__PredictionNotReported();\n        }\n        _;\n    }\n\n    /// Checkpoint 8 ///\n    modifier notOwner() {\n        if (msg.sender == owner()) {\n            revert PredictionMarket__OwnerCannotCall();\n        }\n        _;\n    }\n\n    modifier amountGreaterThanZero(uint256 _amount) {\n        if (_amount == 0) {\n            revert PredictionMarket__AmountMustBeGreaterThanZero();\n        }\n        _;\n    }\n\n    //////////////////\n    ////Constructor///\n    //////////////////\n\n    constructor(\n        address _liquidityProvider,\n        address _oracle,\n        string memory _question,\n        uint256 _initialTokenValue,\n        uint8 _initialYesProbability,\n        uint8 _percentageToLock\n    ) payable Ownable(_liquidityProvider) {\n        /// Checkpoint 2 ////\n        if (msg.value == 0) {\n            revert PredictionMarket__MustProvideETHForInitialLiquidity();\n        }\n        if (_initialYesProbability >= 100 || _initialYesProbability == 0) {\n            revert PredictionMarket__InvalidProbability();\n        }\n\n        if (_percentageToLock >= 100 || _percentageToLock == 0) {\n            revert PredictionMarket__InvalidPercentageToLock();\n        }\n\n        i_oracle = _oracle;\n        s_question = _question;\n        i_initialTokenValue = _initialTokenValue;\n        i_initialYesProbability = _initialYesProbability;\n        i_percentageLocked = _percentageToLock;\n\n        s_ethCollateral = msg.value;\n\n        /// Checkpoint 3 ////\n        uint256 initialTokenAmount = (msg.value * PRECISION) / _initialTokenValue;\n        i_yesToken = new PredictionMarketToken(\"Yes\", \"Y\", msg.sender, initialTokenAmount);\n        i_noToken = new PredictionMarketToken(\"No\", \"N\", msg.sender, initialTokenAmount);\n\n        uint256 initialYesAmountLocked = (initialTokenAmount * _initialYesProbability * _percentageToLock * 2) / 10000;\n        uint256 initialNoAmountLocked =\n            (initialTokenAmount * (100 - _initialYesProbability) * _percentageToLock * 2) / 10000;\n\n        bool success1 = i_yesToken.transfer(msg.sender, initialYesAmountLocked);\n        bool success2 = i_noToken.transfer(msg.sender, initialNoAmountLocked);\n        if (!success1 || !success2) {\n            revert PredictionMarket__TokenTransferFailed();\n        }\n    }\n\n    /////////////////\n    /// Functions ///\n    /////////////////\n\n    /**\n     * @notice Add liquidity to the prediction market and mint tokens\n     * @dev Only the owner can add liquidity and only if the prediction is not reported\n     */\n    function addLiquidity() external payable onlyOwner predictionNotReported {\n        //// Checkpoint 4 ////\n        s_ethCollateral += msg.value;\n\n        uint256 tokensAmount = (msg.value * PRECISION) / i_initialTokenValue;\n\n        i_yesToken.mint(address(this), tokensAmount);\n        i_noToken.mint(address(this), tokensAmount);\n\n        emit LiquidityAdded(msg.sender, msg.value, tokensAmount);\n    }\n\n    /**\n     * @notice Remove liquidity from the prediction market and burn respective tokens, if you remove liquidity before prediction ends you got no share of lpReserve\n     * @dev Only the owner can remove liquidity and only if the prediction is not reported\n     * @param _ethToWithdraw Amount of ETH to withdraw from liquidity pool\n     */\n    function removeLiquidity(uint256 _ethToWithdraw) external onlyOwner predictionNotReported {\n        //// Checkpoint 4 ////\n        uint256 amountTokenToBurn = (_ethToWithdraw / i_initialTokenValue) * PRECISION;\n\n        if (amountTokenToBurn > (i_yesToken.balanceOf(address(this)))) {\n            revert PredictionMarket__InsufficientTokenReserve(Outcome.YES, amountTokenToBurn);\n        }\n\n        if (amountTokenToBurn > (i_noToken.balanceOf(address(this)))) {\n            revert PredictionMarket__InsufficientTokenReserve(Outcome.NO, amountTokenToBurn);\n        }\n\n        s_ethCollateral -= _ethToWithdraw;\n\n        i_yesToken.burn(address(this), amountTokenToBurn);\n        i_noToken.burn(address(this), amountTokenToBurn);\n\n        (bool success,) = msg.sender.call{value: _ethToWithdraw}(\"\");\n        if (!success) {\n            revert PredictionMarket__ETHTransferFailed();\n        }\n\n        emit LiquidityRemoved(msg.sender, _ethToWithdraw, amountTokenToBurn);\n    }\n\n    /**\n     * @notice Report the winning outcome for the prediction\n     * @dev Only the oracle can report the winning outcome and only if the prediction is not reported\n     * @param _winningOutcome The winning outcome (YES or NO)\n     */\n    function report(Outcome _winningOutcome) external predictionNotReported {\n        //// Checkpoint 5 ////\n        if (msg.sender != i_oracle) {\n            revert PredictionMarket__OnlyOracleCanReport();\n        }\n        s_winningToken = _winningOutcome == Outcome.YES ? i_yesToken : i_noToken;\n        s_isReported = true;\n        emit MarketReported(msg.sender, _winningOutcome, address(s_winningToken));\n    }\n\n    /**\n     * @notice Owner of contract can redeem winning tokens held by the contract after prediction is resolved and get ETH from the contract including LP revenue and collateral back\n     * @dev Only callable by the owner and only if the prediction is resolved\n     * @return ethRedeemed The amount of ETH redeemed\n     */\n    function resolveMarketAndWithdraw() external onlyOwner predictionReported returns (uint256 ethRedeemed) {\n        /// Checkpoint 6 ////\n        uint256 contractWinningTokens = s_winningToken.balanceOf(address(this));\n        if (contractWinningTokens > 0) {\n            ethRedeemed = (contractWinningTokens * i_initialTokenValue) / PRECISION;\n\n            if (ethRedeemed > s_ethCollateral) {\n                ethRedeemed = s_ethCollateral;\n            }\n\n            s_ethCollateral -= ethRedeemed;\n        }\n\n        uint256 totalEthToSend = ethRedeemed + s_lpTradingRevenue;\n\n        s_lpTradingRevenue = 0;\n\n        s_winningToken.burn(address(this), contractWinningTokens);\n\n        (bool success,) = msg.sender.call{value: totalEthToSend}(\"\");\n        if (!success) {\n            revert PredictionMarket__ETHTransferFailed();\n        }\n\n        emit MarketResolved(msg.sender, totalEthToSend);\n\n        return ethRedeemed;\n    }\n\n    /**\n     * @notice Buy prediction outcome tokens with ETH, need to call priceInETH function first to get right amount of tokens to buy\n     * @param _outcome The possible outcome (YES or NO) to buy tokens for\n     * @param _amountTokenToBuy Amount of tokens to purchase\n     */\n    function buyTokensWithETH(Outcome _outcome, uint256 _amountTokenToBuy) \n        external \n        payable \n        amountGreaterThanZero(_amountTokenToBuy)\n        predictionNotReported\n        notOwner\n    {\n        /// Checkpoint 8 ////\n        uint256 ethNeeded = getBuyPriceInEth(_outcome, _amountTokenToBuy);\n        if (msg.value != ethNeeded) {\n            revert PredictionMarket__MustSendExactETHAmount();\n        }\n\n        PredictionMarketToken optionToken = _outcome == Outcome.YES ? i_yesToken : i_noToken;\n\n        if (_amountTokenToBuy > optionToken.balanceOf(address(this))) {\n            revert PredictionMarket__InsufficientTokenReserve(_outcome, _amountTokenToBuy);\n        }\n\n        s_lpTradingRevenue += msg.value;\n\n        bool success = optionToken.transfer(msg.sender, _amountTokenToBuy);\n        if (!success) {\n            revert PredictionMarket__TokenTransferFailed();\n        }\n\n        emit TokensPurchased(msg.sender, _outcome, _amountTokenToBuy, msg.value);\n    }\n\n    /**\n     * @notice Sell prediction outcome tokens for ETH, need to call priceInETH function first to get right amount of tokens to buy\n     * @param _outcome The possible outcome (YES or NO) to sell tokens for\n     * @param _tradingAmount The amount of tokens to sell\n     */\n    function sellTokensForEth(Outcome _outcome, uint256 _tradingAmount)\n        external\n        amountGreaterThanZero(_tradingAmount)\n        predictionNotReported\n        notOwner\n    {\n        /// Checkpoint 8 ////\n        PredictionMarketToken optionToken = _outcome == Outcome.YES ? i_yesToken : i_noToken;\n        uint256 userBalance = optionToken.balanceOf(msg.sender);\n        if (userBalance < _tradingAmount) {\n            revert PredictionMarket__InsufficientBalance(_tradingAmount, userBalance);\n        }\n\n        uint256 allowance = optionToken.allowance(msg.sender, address(this));\n        if (allowance < _tradingAmount) {\n            revert PredictionMarket__InsufficientAllowance(_tradingAmount, allowance);\n        }\n\n        uint256 ethToReceive = getSellPriceInEth(_outcome, _tradingAmount);\n\n        s_lpTradingRevenue -= ethToReceive;\n\n        (bool sent,) = msg.sender.call{value: ethToReceive}(\"\");\n        if (!sent) {\n            revert PredictionMarket__ETHTransferFailed();\n        }\n\n        bool success = optionToken.transferFrom(msg.sender, address(this), _tradingAmount);\n        if (!success) {\n            revert PredictionMarket__TokenTransferFailed();\n        }\n\n        emit TokensSold(msg.sender, _outcome, _tradingAmount, ethToReceive);\n    }\n\n    /**\n     * @notice Redeem winning tokens for ETH after prediction is resolved, winning tokens are burned and user receives ETH\n     * @dev Only if the prediction is resolved\n     * @param _amount The amount of winning tokens to redeem\n     */\n    function redeemWinningTokens(uint256 _amount) external amountGreaterThanZero(_amount) predictionReported notOwner {\n        /// Checkpoint 9 ////\n        if (s_winningToken.balanceOf(msg.sender) < _amount) {\n            revert PredictionMarket__InsufficientWinningTokens();\n        }\n\n        uint256 ethToReceive = (_amount * i_initialTokenValue) / PRECISION;\n\n        s_ethCollateral -= ethToReceive;\n\n        s_winningToken.burn(msg.sender, _amount);\n\n        (bool success,) = msg.sender.call{value: ethToReceive}(\"\");\n        if (!success) {\n            revert PredictionMarket__ETHTransferFailed();\n        }\n\n        emit WinningTokensRedeemed(msg.sender, _amount, ethToReceive);\n    }\n\n    /**\n     * @notice Calculate the total ETH price for buying tokens\n     * @param _outcome The possible outcome (YES or NO) to buy tokens for\n     * @param _tradingAmount The amount of tokens to buy\n     * @return The total ETH price\n     */\n    function getBuyPriceInEth(Outcome _outcome, uint256 _tradingAmount) public view returns (uint256) {\n        /// Checkpoint 7 ////\n        return _calculatePriceInEth(_outcome, _tradingAmount, false);\n    }\n\n    /**\n     * @notice Calculate the total ETH price for selling tokens\n     * @param _outcome The possible outcome (YES or NO) to sell tokens for\n     * @param _tradingAmount The amount of tokens to sell\n     * @return The total ETH price\n     */\n    function getSellPriceInEth(Outcome _outcome, uint256 _tradingAmount) public view returns (uint256) {\n        /// Checkpoint 7 ////\n        return _calculatePriceInEth(_outcome, _tradingAmount, true);\n    }\n\n    /////////////////////////\n    /// Helper Functions ///\n    ////////////////////////\n\n    /**\n     * @dev Internal helper to calculate ETH price for both buying and selling\n     * @param _outcome The possible outcome (YES or NO)\n     * @param _tradingAmount The amount of tokens\n     * @param _isSelling Whether this is a sell calculation\n     */\n    function _calculatePriceInEth(\n        Outcome _outcome,\n        uint256 _tradingAmount,\n        bool _isSelling\n    ) private view returns (uint256) {\n        /// Checkpoint 7 ////\n        (uint256 currentTokenReserve, uint256 currentOtherTokenReserve) = _getCurrentReserves(_outcome);\n\n        /// Ensure sufficient liquidity when buying\n        if (!_isSelling) {\n            if (currentTokenReserve < _tradingAmount) {\n                revert PredictionMarket__InsufficientLiquidity();\n            }\n        }\n\n        uint256 totalTokenSupply = i_yesToken.totalSupply();\n\n        /// Before trade\n        uint256 currentTokenSoldBefore = totalTokenSupply - currentTokenReserve;\n        uint256 currentOtherTokenSold = totalTokenSupply - currentOtherTokenReserve;\n\n        uint256 totalTokensSoldBefore = currentTokenSoldBefore + currentOtherTokenSold;\n        uint256 probabilityBefore = _calculateProbability(currentTokenSoldBefore, totalTokensSoldBefore);\n\n        /// After trade\n        uint256 currentTokenReserveAfter =\n            _isSelling ? currentTokenReserve + _tradingAmount : currentTokenReserve - _tradingAmount;\n        uint256 currentTokenSoldAfter = totalTokenSupply - currentTokenReserveAfter;\n\n        uint256 totalTokensSoldAfter =\n            _isSelling ? totalTokensSoldBefore - _tradingAmount : totalTokensSoldBefore + _tradingAmount;\n\n        uint256 probabilityAfter = _calculateProbability(currentTokenSoldAfter, totalTokensSoldAfter);\n\n        /// Compute final price\n        uint256 probabilityAvg = (probabilityBefore + probabilityAfter) / 2;\n        return (i_initialTokenValue * probabilityAvg * _tradingAmount) / (PRECISION * PRECISION);\n    }\n\n    /**\n     * @dev Internal helper to get the current reserves of the tokens\n     * @param _outcome The possible outcome (YES or NO)\n     * @return The current reserves of the tokens\n     */\n    function _getCurrentReserves(Outcome _outcome) private view returns (uint256, uint256) {\n        /// Checkpoint 7 ////\n        if (_outcome == Outcome.YES) {\n            return (i_yesToken.balanceOf(address(this)), i_noToken.balanceOf(address(this)));\n        } else {\n            return (i_noToken.balanceOf(address(this)), i_yesToken.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @dev Internal helper to calculate the probability of the tokens\n     * @param tokensSold The number of tokens sold\n     * @param totalSold The total number of tokens sold\n     * @return The probability of the tokens\n     */\n    function _calculateProbability(uint256 tokensSold, uint256 totalSold) private pure returns (uint256) {\n        /// Checkpoint 7 ////\n        return (tokensSold * PRECISION) / totalSold;\n    }\n\n    /////////////////////////\n    /// Getter Functions ///\n    ////////////////////////\n\n    /**\n     * @notice Get the prediction details\n     */\n    function getPrediction()\n        external\n        view\n        returns (\n            string memory question,\n            string memory outcome1,\n            string memory outcome2,\n            address oracle,\n            uint256 initialTokenValue,\n            uint256 yesTokenReserve,\n            uint256 noTokenReserve,\n            bool isReported,\n            address yesToken,\n            address noToken,\n            address winningToken,\n            uint256 ethCollateral,\n            uint256 lpTradingRevenue,\n            address predictionMarketOwner,\n            uint256 initialProbability,\n            uint256 percentageLocked\n        )\n    {\n        /// Checkpoint 3 ////\n        oracle = i_oracle;\n        initialTokenValue = i_initialTokenValue;\n        percentageLocked = i_percentageLocked;\n        initialProbability = i_initialYesProbability;\n        question = s_question;\n        ethCollateral = s_ethCollateral;\n        lpTradingRevenue = s_lpTradingRevenue;\n        predictionMarketOwner = owner();\n        yesToken = address(i_yesToken);\n        noToken = address(i_noToken);\n        outcome1 = i_yesToken.name();\n        outcome2 = i_noToken.name();\n        yesTokenReserve = i_yesToken.balanceOf(address(this));\n        noTokenReserve = i_noToken.balanceOf(address(this));\n        /// Checkpoint 5 ////\n        isReported = s_isReported;\n        winningToken = address(s_winningToken);\n    }\n}\n"
    },
    "contracts/PredictionMarketToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract PredictionMarketToken is ERC20 {\n    error PredictionMarketToken__OnlyPredictionMarketCanMint();\n    error PredictionMarketToken__OnlyPredictionMarketCanBurn();\n    error PredictionMarketToken__LiquidityProviderCantTransfer();\n\n    address public predictionMarket;\n    address public liquidityProvider;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _liquidityProvider,\n        uint256 initialSupply\n    ) ERC20(name, symbol) {\n        predictionMarket = msg.sender;\n        liquidityProvider = _liquidityProvider;\n        _mint(msg.sender, initialSupply);\n    }\n\n    function mint(address to, uint256 amount) external {\n        if (msg.sender != predictionMarket) {\n            revert PredictionMarketToken__OnlyPredictionMarketCanMint();\n        }\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external {\n        if (msg.sender != predictionMarket) {\n            revert PredictionMarketToken__OnlyPredictionMarketCanBurn();\n        }\n        _burn(from, amount);\n    }\n\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        if (msg.sender == liquidityProvider) {\n            revert PredictionMarketToken__LiquidityProviderCantTransfer();\n        }\n        return super.transfer(to, amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n        if (from == liquidityProvider) {\n            revert PredictionMarketToken__LiquidityProviderCantTransfer();\n        }\n        return super.transferFrom(from, to, amount);\n    }\n}\n"
    },
    "contracts/PredictionMarketTTrust.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { PredictionMarketToken } from \"./PredictionMarketToken.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PredictionMarketTTrust is Ownable {\n    /////////////////\n    /// Errors //////\n    /////////////////\n\n    error PredictionMarketTTrust__MustProvideTTrustForInitialLiquidity();\n    error PredictionMarketTTrust__InvalidProbability();\n    error PredictionMarketTTrust__PredictionAlreadyReported();\n    error PredictionMarketTTrust__OnlyOracleCanReport();\n    error PredictionMarketTTrust__OwnerCannotCall();\n    error PredictionMarketTTrust__PredictionNotReported();\n    error PredictionMarketTTrust__InsufficientWinningTokens();\n    error PredictionMarketTTrust__AmountMustBeGreaterThanZero();\n    error PredictionMarketTTrust__InsufficientTokenReserve(Outcome _outcome, uint256 _amountToken);\n    error PredictionMarketTTrust__TokenTransferFailed();\n    error PredictionMarketTTrust__TTrustTransferFailed();\n    error PredictionMarketTTrust__InsufficientBalance(uint256 _tradingAmount, uint256 _userBalance);\n    error PredictionMarketTTrust__InsufficientAllowance(uint256 _tradingAmount, uint256 _allowance);\n    error PredictionMarketTTrust__InsufficientLiquidity();\n    error PredictionMarketTTrust__InvalidPercentageToLock();\n    error PredictionMarketTTrust__InsufficientTTrustAllowance();\n\n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n\n    enum Outcome {\n        YES,\n        NO\n    }\n\n    uint256 private constant PRECISION = 1e18;\n\n    /// TTrust token contract\n    IERC20 public immutable i_ttrustToken;\n\n    /// Checkpoint 2 ///\n    address public immutable i_oracle;\n    uint256 public immutable i_initialTokenValue;\n    uint256 public immutable i_percentageLocked;\n    uint256 public immutable i_initialYesProbability;\n\n    string public s_question;\n    uint256 public s_ttrustCollateral;\n    uint256 public s_lpTradingRevenue;\n\n    /// Checkpoint 3 ///\n    PredictionMarketToken public immutable i_yesToken;\n    PredictionMarketToken public immutable i_noToken;\n\n    /// Checkpoint 5 ///\n    PredictionMarketToken public s_winningToken;\n    bool public s_isReported;\n\n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n\n    event TokensPurchased(address indexed buyer, Outcome outcome, uint256 amount, uint256 ttrustAmount);\n    event TokensSold(address indexed seller, Outcome outcome, uint256 amount, uint256 ttrustAmount);\n    event WinningTokensRedeemed(address indexed redeemer, uint256 amount, uint256 ttrustAmount);\n    event MarketReported(address indexed oracle, Outcome winningOutcome, address winningToken);\n    event MarketResolved(address indexed resolver, uint256 totalTTrustToSend);\n    event LiquidityAdded(address indexed provider, uint256 ttrustAmount, uint256 tokensAmount);\n    event LiquidityRemoved(address indexed provider, uint256 ttrustAmount, uint256 tokensAmount);\n\n    /////////////////\n    /// Modifiers ///\n    /////////////////\n\n    /// Checkpoint 5 ///\n    modifier predictionNotReported() {\n        if (s_isReported) {\n            revert PredictionMarketTTrust__PredictionAlreadyReported();\n        }\n        _;\n    }\n\n    /// Checkpoint 6 ///\n    modifier predictionReported() {\n        if (!s_isReported) {\n            revert PredictionMarketTTrust__PredictionNotReported();\n        }\n        _;\n    }\n\n    /// Checkpoint 8 ///\n    modifier notOwner() {\n        if (msg.sender == owner()) {\n            revert PredictionMarketTTrust__OwnerCannotCall();\n        }\n        _;\n    }\n\n    modifier amountGreaterThanZero(uint256 _amount) {\n        if (_amount == 0) {\n            revert PredictionMarketTTrust__AmountMustBeGreaterThanZero();\n        }\n        _;\n    }\n\n    //////////////////\n    ////Constructor///\n    //////////////////\n\n    constructor(\n        address _liquidityProvider,\n        address _oracle,\n        address _ttrustToken,\n        string memory _question,\n        uint256 _initialTokenValue,\n        uint8 _initialYesProbability,\n        uint8 _percentageToLock,\n        uint256 _initialTTrustLiquidity\n    ) Ownable(_liquidityProvider) {\n        /// Checkpoint 2 ////\n        if (_initialTTrustLiquidity == 0) {\n            revert PredictionMarketTTrust__MustProvideTTrustForInitialLiquidity();\n        }\n        if (_initialYesProbability >= 100 || _initialYesProbability == 0) {\n            revert PredictionMarketTTrust__InvalidProbability();\n        }\n        if (_percentageToLock >= 100 || _percentageToLock == 0) {\n            revert PredictionMarketTTrust__InvalidPercentageToLock();\n        }\n\n        i_ttrustToken = IERC20(_ttrustToken);\n        i_oracle = _oracle;\n        s_question = _question;\n        i_initialTokenValue = _initialTokenValue;\n        i_initialYesProbability = _initialYesProbability;\n        i_percentageLocked = _percentageToLock;\n\n        // Transfer initial TTrust liquidity from deployer\n        bool success = i_ttrustToken.transferFrom(_liquidityProvider, address(this), _initialTTrustLiquidity);\n        if (!success) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        s_ttrustCollateral = _initialTTrustLiquidity;\n\n        /// Checkpoint 3 ////\n        uint256 initialTokenAmount = (_initialTTrustLiquidity * PRECISION) / _initialTokenValue;\n        i_yesToken = new PredictionMarketToken(\"Yes\", \"Y\", msg.sender, initialTokenAmount);\n        i_noToken = new PredictionMarketToken(\"No\", \"N\", msg.sender, initialTokenAmount);\n\n        uint256 initialYesAmountLocked = (initialTokenAmount * _initialYesProbability * _percentageToLock * 2) / 10000;\n        uint256 initialNoAmountLocked = (initialTokenAmount * (100 - _initialYesProbability) * _percentageToLock * 2) / 10000;\n\n        bool success1 = i_yesToken.transfer(msg.sender, initialYesAmountLocked);\n        bool success2 = i_noToken.transfer(msg.sender, initialNoAmountLocked);\n        if (!success1 || !success2) {\n            revert PredictionMarketTTrust__TokenTransferFailed();\n        }\n    }\n\n    /////////////////\n    /// Functions ///\n    /////////////////\n\n    /**\n     * @notice Add liquidity to the prediction market with TTrust\n     * @dev Only the owner can add liquidity and only if the prediction is not reported\n     * @param _ttrustAmount Amount of TTrust to add as liquidity\n     */\n    function addLiquidity(uint256 _ttrustAmount) external onlyOwner predictionNotReported {\n        //// Checkpoint 4 ////\n        bool success = i_ttrustToken.transferFrom(msg.sender, address(this), _ttrustAmount);\n        if (!success) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        s_ttrustCollateral += _ttrustAmount;\n\n        uint256 tokensAmount = (_ttrustAmount * PRECISION) / i_initialTokenValue;\n\n        i_yesToken.mint(address(this), tokensAmount);\n        i_noToken.mint(address(this), tokensAmount);\n\n        emit LiquidityAdded(msg.sender, _ttrustAmount, tokensAmount);\n    }\n\n    /**\n     * @notice Remove liquidity from the prediction market\n     * @param _ttrustToWithdraw Amount of TTrust to withdraw from liquidity pool\n     */\n    function removeLiquidity(uint256 _ttrustToWithdraw) external onlyOwner predictionNotReported {\n        //// Checkpoint 4 ////\n        uint256 amountTokenToBurn = (_ttrustToWithdraw / i_initialTokenValue) * PRECISION;\n\n        if (amountTokenToBurn > (i_yesToken.balanceOf(address(this)))) {\n            revert PredictionMarketTTrust__InsufficientTokenReserve(Outcome.YES, amountTokenToBurn);\n        }\n        if (amountTokenToBurn > (i_noToken.balanceOf(address(this)))) {\n            revert PredictionMarketTTrust__InsufficientTokenReserve(Outcome.NO, amountTokenToBurn);\n        }\n\n        s_ttrustCollateral -= _ttrustToWithdraw;\n\n        i_yesToken.burn(address(this), amountTokenToBurn);\n        i_noToken.burn(address(this), amountTokenToBurn);\n\n        bool success = i_ttrustToken.transfer(msg.sender, _ttrustToWithdraw);\n        if (!success) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        emit LiquidityRemoved(msg.sender, _ttrustToWithdraw, amountTokenToBurn);\n    }\n\n    /**\n     * @notice Report the winning outcome for the prediction\n     */\n    function report(Outcome _winningOutcome) external predictionNotReported {\n        //// Checkpoint 5 ////\n        if (msg.sender != i_oracle) {\n            revert PredictionMarketTTrust__OnlyOracleCanReport();\n        }\n        s_winningToken = _winningOutcome == Outcome.YES ? i_yesToken : i_noToken;\n        s_isReported = true;\n        emit MarketReported(msg.sender, _winningOutcome, address(s_winningToken));\n    }\n\n    /**\n     * @notice Owner can withdraw profits after resolution\n     */\n    function resolveMarketAndWithdraw() external onlyOwner predictionReported returns (uint256 ttrustRedeemed) {\n        /// Checkpoint 6 ////\n        uint256 contractWinningTokens = s_winningToken.balanceOf(address(this));\n        if (contractWinningTokens > 0) {\n            ttrustRedeemed = (contractWinningTokens * i_initialTokenValue) / PRECISION;\n\n            if (ttrustRedeemed > s_ttrustCollateral) {\n                ttrustRedeemed = s_ttrustCollateral;\n            }\n\n            s_ttrustCollateral -= ttrustRedeemed;\n        }\n\n        uint256 totalTTrustToSend = ttrustRedeemed + s_lpTradingRevenue;\n        s_lpTradingRevenue = 0;\n\n        s_winningToken.burn(address(this), contractWinningTokens);\n\n        bool success = i_ttrustToken.transfer(msg.sender, totalTTrustToSend);\n        if (!success) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        emit MarketResolved(msg.sender, totalTTrustToSend);\n        return ttrustRedeemed;\n    }\n\n    /**\n     * @notice Buy prediction tokens with TTrust\n     */\n    function buyTokensWithTTrust(Outcome _outcome, uint256 _amountTokenToBuy) \n        external \n        amountGreaterThanZero(_amountTokenToBuy)\n        predictionNotReported\n        notOwner\n    {\n        /// Checkpoint 8 ////\n        uint256 ttrustNeeded = getBuyPriceInTTrust(_outcome, _amountTokenToBuy);\n        \n        // Check allowance and balance\n        uint256 allowance = i_ttrustToken.allowance(msg.sender, address(this));\n        if (allowance < ttrustNeeded) {\n            revert PredictionMarketTTrust__InsufficientTTrustAllowance();\n        }\n\n        uint256 balance = i_ttrustToken.balanceOf(msg.sender);\n        if (balance < ttrustNeeded) {\n            revert PredictionMarketTTrust__InsufficientBalance(ttrustNeeded, balance);\n        }\n\n        PredictionMarketToken optionToken = _outcome == Outcome.YES ? i_yesToken : i_noToken;\n\n        if (_amountTokenToBuy > optionToken.balanceOf(address(this))) {\n            revert PredictionMarketTTrust__InsufficientTokenReserve(_outcome, _amountTokenToBuy);\n        }\n\n        // Transfer TTrust from user\n        bool success1 = i_ttrustToken.transferFrom(msg.sender, address(this), ttrustNeeded);\n        if (!success1) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        s_lpTradingRevenue += ttrustNeeded;\n\n        bool success2 = optionToken.transfer(msg.sender, _amountTokenToBuy);\n        if (!success2) {\n            revert PredictionMarketTTrust__TokenTransferFailed();\n        }\n\n        emit TokensPurchased(msg.sender, _outcome, _amountTokenToBuy, ttrustNeeded);\n    }\n\n    /**\n     * @notice Sell prediction tokens for TTrust\n     */\n    function sellTokensForTTrust(Outcome _outcome, uint256 _tradingAmount)\n        external\n        amountGreaterThanZero(_tradingAmount)\n        predictionNotReported\n        notOwner\n    {\n        /// Checkpoint 8 ////\n        PredictionMarketToken optionToken = _outcome == Outcome.YES ? i_yesToken : i_noToken;\n        uint256 userBalance = optionToken.balanceOf(msg.sender);\n        if (userBalance < _tradingAmount) {\n            revert PredictionMarketTTrust__InsufficientBalance(_tradingAmount, userBalance);\n        }\n\n        uint256 allowance = optionToken.allowance(msg.sender, address(this));\n        if (allowance < _tradingAmount) {\n            revert PredictionMarketTTrust__InsufficientAllowance(_tradingAmount, allowance);\n        }\n\n        uint256 ttrustToReceive = getSellPriceInTTrust(_outcome, _tradingAmount);\n\n        s_lpTradingRevenue -= ttrustToReceive;\n\n        bool success1 = i_ttrustToken.transfer(msg.sender, ttrustToReceive);\n        if (!success1) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        bool success2 = optionToken.transferFrom(msg.sender, address(this), _tradingAmount);\n        if (!success2) {\n            revert PredictionMarketTTrust__TokenTransferFailed();\n        }\n\n        emit TokensSold(msg.sender, _outcome, _tradingAmount, ttrustToReceive);\n    }\n\n    /**\n     * @notice Redeem winning tokens for TTrust\n     */\n    function redeemWinningTokens(uint256 _amount) external amountGreaterThanZero(_amount) predictionReported notOwner {\n        /// Checkpoint 9 ////\n        if (s_winningToken.balanceOf(msg.sender) < _amount) {\n            revert PredictionMarketTTrust__InsufficientWinningTokens();\n        }\n\n        uint256 ttrustToReceive = (_amount * i_initialTokenValue) / PRECISION;\n        s_ttrustCollateral -= ttrustToReceive;\n\n        s_winningToken.burn(msg.sender, _amount);\n\n        bool success = i_ttrustToken.transfer(msg.sender, ttrustToReceive);\n        if (!success) {\n            revert PredictionMarketTTrust__TTrustTransferFailed();\n        }\n\n        emit WinningTokensRedeemed(msg.sender, _amount, ttrustToReceive);\n    }\n\n    /**\n     * @notice Calculate TTrust price for buying tokens\n     */\n    function getBuyPriceInTTrust(Outcome _outcome, uint256 _tradingAmount) public view returns (uint256) {\n        /// Checkpoint 7 ////\n        return _calculatePriceInTTrust(_outcome, _tradingAmount, false);\n    }\n\n    /**\n     * @notice Calculate TTrust price for selling tokens\n     */\n    function getSellPriceInTTrust(Outcome _outcome, uint256 _tradingAmount) public view returns (uint256) {\n        /// Checkpoint 7 ////\n        return _calculatePriceInTTrust(_outcome, _tradingAmount, true);\n    }\n\n    /////////////////////////\n    /// Helper Functions ///\n    ////////////////////////\n\n    /**\n     * @dev Internal helper to calculate TTrust price for both buying and selling\n     */\n    function _calculatePriceInTTrust(\n        Outcome _outcome,\n        uint256 _tradingAmount,\n        bool _isSelling\n    ) private view returns (uint256) {\n        /// Checkpoint 7 ////\n        (uint256 currentTokenReserve, uint256 currentOtherTokenReserve) = _getCurrentReserves(_outcome);\n\n        /// Ensure sufficient liquidity when buying\n        if (!_isSelling) {\n            if (currentTokenReserve < _tradingAmount) {\n                revert PredictionMarketTTrust__InsufficientLiquidity();\n            }\n        }\n\n        uint256 totalTokenSupply = i_yesToken.totalSupply();\n\n        /// Before trade\n        uint256 currentTokenSoldBefore = totalTokenSupply - currentTokenReserve;\n        uint256 currentOtherTokenSold = totalTokenSupply - currentOtherTokenReserve;\n\n        uint256 totalTokensSoldBefore = currentTokenSoldBefore + currentOtherTokenSold;\n        uint256 probabilityBefore = _calculateProbability(currentTokenSoldBefore, totalTokensSoldBefore);\n\n        /// After trade\n        uint256 currentTokenReserveAfter =\n            _isSelling ? currentTokenReserve + _tradingAmount : currentTokenReserve - _tradingAmount;\n        uint256 currentTokenSoldAfter = totalTokenSupply - currentTokenReserveAfter;\n\n        uint256 totalTokensSoldAfter =\n            _isSelling ? totalTokensSoldBefore - _tradingAmount : totalTokensSoldBefore + _tradingAmount;\n\n        uint256 probabilityAfter = _calculateProbability(currentTokenSoldAfter, totalTokensSoldAfter);\n\n        /// Compute final price\n        uint256 probabilityAvg = (probabilityBefore + probabilityAfter) / 2;\n        return (i_initialTokenValue * probabilityAvg * _tradingAmount) / (PRECISION * PRECISION);\n    }\n\n    function _getCurrentReserves(Outcome _outcome) private view returns (uint256, uint256) {\n        if (_outcome == Outcome.YES) {\n            return (i_yesToken.balanceOf(address(this)), i_noToken.balanceOf(address(this)));\n        } else {\n            return (i_noToken.balanceOf(address(this)), i_yesToken.balanceOf(address(this)));\n        }\n    }\n\n    function _calculateProbability(uint256 tokensSold, uint256 totalSold) private pure returns (uint256) {\n        return (tokensSold * PRECISION) / totalSold;\n    }\n\n    /////////////////////////\n    /// Getter Functions ///\n    ////////////////////////\n\n    /**\n     * @notice Get the prediction details\n     */\n    function getPrediction()\n        external\n        view\n        returns (\n            string memory question,\n            string memory outcome1,\n            string memory outcome2,\n            address oracle,\n            uint256 initialTokenValue,\n            uint256 yesTokenReserve,\n            uint256 noTokenReserve,\n            bool isReported,\n            address yesToken,\n            address noToken,\n            address winningToken,\n            uint256 ttrustCollateral,\n            uint256 lpTradingRevenue,\n            address predictionMarketOwner,\n            uint256 initialProbability,\n            uint256 percentageLocked,\n            address ttrustToken\n        )\n    {\n        oracle = i_oracle;\n        initialTokenValue = i_initialTokenValue;\n        percentageLocked = i_percentageLocked;\n        initialProbability = i_initialYesProbability;\n        question = s_question;\n        ttrustCollateral = s_ttrustCollateral;\n        lpTradingRevenue = s_lpTradingRevenue;\n        predictionMarketOwner = owner();\n        yesToken = address(i_yesToken);\n        noToken = address(i_noToken);\n        outcome1 = i_yesToken.name();\n        outcome2 = i_noToken.name();\n        yesTokenReserve = i_yesToken.balanceOf(address(this));\n        noTokenReserve = i_noToken.balanceOf(address(this));\n        isReported = s_isReported;\n        winningToken = address(s_winningToken);\n        ttrustToken = address(i_ttrustToken);\n    }\n}"
    },
    "contracts/TTrustMarketCapPrediction.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { PredictionMarket } from \"./PredictionMarket.sol\";\nimport { TTrustPriceOracle } from \"./TTrustPriceOracle.sol\";\nimport { PredictionMarketToken } from \"./PredictionMarketToken.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TTrustMarketCapPrediction\n * @notice Prediction market for TTrust token market cap predictions\n * @dev Extends the base PredictionMarket with TTrust-specific logic\n */\ncontract TTrustMarketCapPrediction is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error TTrustMarketCapPrediction__MarketNotResolved();\n    error TTrustMarketCapPrediction__MarketAlreadyResolved();\n    error TTrustMarketCapPrediction__DeadlinePassed();\n    error TTrustMarketCapPrediction__DeadlineNotReached();\n    error TTrustMarketCapPrediction__InvalidTargetValue();\n    error TTrustMarketCapPrediction__OracleDataStale();\n    error TTrustMarketCapPrediction__InvalidPredictionType();\n    \n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n    \n    enum PredictionType {\n        MARKET_CAP_ABOVE,     // Market cap will be above target\n        MARKET_CAP_BELOW,     // Market cap will be below target\n        PRICE_ABOVE,          // Price will be above target\n        PRICE_BELOW           // Price will be below target\n    }\n    \n    struct PredictionDetails {\n        PredictionType predictionType;\n        uint256 targetValue;        // Target market cap or price (18 decimals)\n        uint256 deadline;           // When prediction expires\n        string description;         // Human readable description\n        bool isResolved;           // Has this prediction been resolved\n        bool targetReached;        // Did target get reached\n        uint256 resolutionValue;   // Actual value at resolution time\n        uint256 resolutionTime;    // When it was resolved\n    }\n    \n    // Core prediction market contract (handles token trading)\n    PredictionMarket public immutable predictionMarket;\n    \n    // Oracle for TTrust price/market cap data\n    TTrustPriceOracle public immutable priceOracle;\n    \n    // Prediction details\n    PredictionDetails public prediction;\n    \n    uint256 public constant PRECISION = 1e18;\n    uint256 public constant RESOLUTION_BUFFER = 1 hours; // Grace period after deadline\n    \n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n    \n    event PredictionCreated(\n        PredictionType indexed predictionType,\n        uint256 indexed targetValue,\n        uint256 indexed deadline,\n        string description\n    );\n    \n    event PredictionResolved(\n        bool indexed targetReached,\n        uint256 actualValue,\n        uint256 targetValue,\n        uint256 resolutionTime\n    );\n    \n    event EmergencyResolution(\n        bool targetReached,\n        string reason\n    );\n    \n    /////////////////\n    /// Modifiers ///\n    /////////////////\n    \n    modifier beforeDeadline() {\n        if (block.timestamp >= prediction.deadline) {\n            revert TTrustMarketCapPrediction__DeadlinePassed();\n        }\n        _;\n    }\n    \n    modifier afterDeadline() {\n        if (block.timestamp < prediction.deadline + RESOLUTION_BUFFER) {\n            revert TTrustMarketCapPrediction__DeadlineNotReached();\n        }\n        _;\n    }\n    \n    modifier notResolved() {\n        if (prediction.isResolved) {\n            revert TTrustMarketCapPrediction__MarketAlreadyResolved();\n        }\n        _;\n    }\n    \n    modifier resolved() {\n        if (!prediction.isResolved) {\n            revert TTrustMarketCapPrediction__MarketNotResolved();\n        }\n        _;\n    }\n    \n    //////////////////\n    ////Constructor///\n    //////////////////\n    \n    constructor(\n        address _liquidityProvider,\n        address _priceOracle,\n        PredictionType _predictionType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _initialTokenValue,\n        uint8 _initialYesProbability,\n        uint8 _percentageToLock\n    ) payable Ownable(_liquidityProvider) {\n        \n        if (_targetValue == 0) {\n            revert TTrustMarketCapPrediction__InvalidTargetValue();\n        }\n        \n        if (_deadline <= block.timestamp) {\n            revert TTrustMarketCapPrediction__DeadlinePassed();\n        }\n        \n        // Set oracle\n        priceOracle = TTrustPriceOracle(_priceOracle);\n        \n        // Store prediction details\n        prediction = PredictionDetails({\n            predictionType: _predictionType,\n            targetValue: _targetValue,\n            deadline: _deadline,\n            description: _description,\n            isResolved: false,\n            targetReached: false,\n            resolutionValue: 0,\n            resolutionTime: 0\n        });\n        \n        // Create underlying prediction market\n        string memory question = _buildQuestionString(_predictionType, _targetValue, _deadline, _description);\n        \n        predictionMarket = new PredictionMarket{value: msg.value}(\n            _liquidityProvider,\n            address(this), // This contract acts as oracle\n            question,\n            _initialTokenValue,\n            _initialYesProbability,\n            _percentageToLock\n        );\n        \n        emit PredictionCreated(_predictionType, _targetValue, _deadline, _description);\n    }\n    \n    /////////////////\n    /// Functions ///\n    /////////////////\n    \n    /**\n     * @notice Buy prediction tokens (YES = target will be reached, NO = target won't be reached)\n     * @param _outcome YES (target reached) or NO (target not reached)\n     * @param _amountTokenToBuy Amount of tokens to purchase\n     */\n    function buyTokens(PredictionMarket.Outcome _outcome, uint256 _amountTokenToBuy) \n        external \n        payable\n        beforeDeadline\n        notResolved\n    {\n        predictionMarket.buyTokensWithETH{value: msg.value}(_outcome, _amountTokenToBuy);\n    }\n    \n    /**\n     * @notice Sell prediction tokens back to the market\n     * @param _outcome YES or NO tokens to sell\n     * @param _tradingAmount Amount of tokens to sell\n     */\n    function sellTokens(PredictionMarket.Outcome _outcome, uint256 _tradingAmount)\n        external\n        beforeDeadline\n        notResolved\n    {\n        predictionMarket.sellTokensForEth(_outcome, _tradingAmount);\n    }\n    \n    /**\n     * @notice Resolve the prediction by checking current TTrust data\n     * @dev Can be called by anyone after deadline + buffer period\n     */\n    function resolvePrediction() external afterDeadline notResolved {\n        \n        // Get current data from oracle\n        (uint256 currentValue, uint256 timestamp) = _getCurrentValue();\n        \n        // Check if oracle data is fresh enough\n        if (block.timestamp - timestamp > 2 hours) {\n            revert TTrustMarketCapPrediction__OracleDataStale();\n        }\n        \n        // Determine if target was reached\n        bool targetReached = _evaluateTarget(currentValue);\n        \n        // Update prediction state\n        prediction.isResolved = true;\n        prediction.targetReached = targetReached;\n        prediction.resolutionValue = currentValue;\n        prediction.resolutionTime = block.timestamp;\n        \n        // Report to underlying prediction market\n        PredictionMarket.Outcome winningOutcome = targetReached ? \n            PredictionMarket.Outcome.YES : \n            PredictionMarket.Outcome.NO;\n            \n        predictionMarket.report(winningOutcome);\n        \n        emit PredictionResolved(targetReached, currentValue, prediction.targetValue, block.timestamp);\n    }\n    \n    /**\n     * @notice Emergency resolution by owner (in case of oracle issues)\n     * @param _targetReached Whether target was reached\n     * @param _reason Reason for emergency resolution\n     */\n    function emergencyResolve(bool _targetReached, string memory _reason) \n        external \n        onlyOwner \n        notResolved \n    {\n        prediction.isResolved = true;\n        prediction.targetReached = _targetReached;\n        prediction.resolutionTime = block.timestamp;\n        \n        PredictionMarket.Outcome winningOutcome = _targetReached ? \n            PredictionMarket.Outcome.YES : \n            PredictionMarket.Outcome.NO;\n            \n        predictionMarket.report(winningOutcome);\n        \n        emit EmergencyResolution(_targetReached, _reason);\n    }\n    \n    /**\n     * @notice Redeem winning tokens after resolution\n     * @param _amount Amount of winning tokens to redeem\n     */\n    function redeemWinningTokens(uint256 _amount) external resolved {\n        predictionMarket.redeemWinningTokens(_amount);\n    }\n    \n    /**\n     * @notice Owner can withdraw profits after resolution\n     */\n    function withdrawProfits() external onlyOwner resolved {\n        predictionMarket.resolveMarketAndWithdraw();\n    }\n    \n    /////////////////////////\n    /// Internal Functions //\n    /////////////////////////\n    \n    /**\n     * @dev Get current value based on prediction type\n     */\n    function _getCurrentValue() internal view returns (uint256 value, uint256 timestamp) {\n        if (prediction.predictionType == PredictionType.MARKET_CAP_ABOVE || \n            prediction.predictionType == PredictionType.MARKET_CAP_BELOW) {\n            return priceOracle.getMarketCap();\n        } else {\n            return priceOracle.getPrice();\n        }\n    }\n    \n    /**\n     * @dev Evaluate if target was reached based on prediction type\n     */\n    function _evaluateTarget(uint256 currentValue) internal view returns (bool) {\n        if (prediction.predictionType == PredictionType.MARKET_CAP_ABOVE || \n            prediction.predictionType == PredictionType.PRICE_ABOVE) {\n            return currentValue >= prediction.targetValue;\n        } else {\n            return currentValue <= prediction.targetValue;\n        }\n    }\n    \n    /**\n     * @dev Build human-readable question string\n     */\n    function _buildQuestionString(\n        PredictionType _type,\n        uint256 _target,\n        uint256 _deadline,\n        string memory _description\n    ) internal pure returns (string memory) {\n        // This is a simplified version - in production you'd format the numbers properly\n        if (_type == PredictionType.MARKET_CAP_ABOVE) {\n            return string(abi.encodePacked(\"Will TTrust market cap exceed target by deadline? \", _description));\n        } else if (_type == PredictionType.MARKET_CAP_BELOW) {\n            return string(abi.encodePacked(\"Will TTrust market cap stay below target by deadline? \", _description));\n        } else if (_type == PredictionType.PRICE_ABOVE) {\n            return string(abi.encodePacked(\"Will TTrust price exceed target by deadline? \", _description));\n        } else {\n            return string(abi.encodePacked(\"Will TTrust price stay below target by deadline? \", _description));\n        }\n    }\n    \n    /////////////////////////\n    /// View Functions //////\n    /////////////////////////\n    \n    /**\n     * @notice Get current TTrust metrics for display\n     */\n    function getCurrentTTrustData() \n        external \n        view \n        returns (\n            uint256 currentPrice,\n            uint256 currentMarketCap,\n            uint256 lastUpdate,\n            bool isStale\n        ) \n    {\n        try priceOracle.getPrice() returns (uint256 price, uint256 timestamp) {\n            currentPrice = price;\n            lastUpdate = timestamp;\n            \n            try priceOracle.getMarketCap() returns (uint256 marketCap, uint256 mcTimestamp) {\n                currentMarketCap = marketCap;\n                if (mcTimestamp > lastUpdate) lastUpdate = mcTimestamp;\n            } catch {\n                currentMarketCap = 0;\n            }\n            \n            isStale = (block.timestamp - lastUpdate) > 2 hours;\n        } catch {\n            currentPrice = 0;\n            currentMarketCap = 0;\n            lastUpdate = 0;\n            isStale = true;\n        }\n    }\n    \n    /**\n     * @notice Get complete prediction information\n     */\n    function getPredictionInfo()\n        external\n        view\n        returns (\n            PredictionType predictionType,\n            uint256 targetValue,\n            uint256 deadline,\n            string memory description,\n            bool isResolved,\n            bool targetReached,\n            uint256 resolutionValue,\n            uint256 resolutionTime,\n            address predictionMarketAddress\n        )\n    {\n        return (\n            prediction.predictionType,\n            prediction.targetValue,\n            prediction.deadline,\n            prediction.description,\n            prediction.isResolved,\n            prediction.targetReached,\n            prediction.resolutionValue,\n            prediction.resolutionTime,\n            address(predictionMarket)\n        );\n    }\n    \n    /**\n     * @notice Get trading information from underlying market\n     */\n    function getTradingInfo()\n        external\n        view\n        returns (\n            uint256 yesTokenPrice,\n            uint256 noTokenPrice,\n            uint256 yesTokenReserve,\n            uint256 noTokenReserve,\n            address yesToken,\n            address noToken\n        )\n    {\n        yesTokenPrice = predictionMarket.getBuyPriceInEth(PredictionMarket.Outcome.YES, 1 ether);\n        noTokenPrice = predictionMarket.getBuyPriceInEth(PredictionMarket.Outcome.NO, 1 ether);\n        \n        (,,, , , yesTokenReserve, noTokenReserve, , yesToken, noToken, , , , , , ) = predictionMarket.getPrediction();\n    }\n    \n    /**\n     * @notice Check if prediction can be resolved\n     */\n    function canResolve() external view returns (bool) {\n        return !prediction.isResolved && \n               block.timestamp >= prediction.deadline + RESOLUTION_BUFFER &&\n               priceOracle.isPriceValid();\n    }\n    \n    /**\n     * @notice Get time left until deadline\n     */\n    function getTimeToDeadline() external view returns (uint256) {\n        if (block.timestamp >= prediction.deadline) {\n            return 0;\n        }\n        return prediction.deadline - block.timestamp;\n    }\n}"
    },
    "contracts/TTrustMarketCapPredictionTTrust.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { PredictionMarketTTrust } from \"./PredictionMarketTTrust.sol\";\nimport { TTrustPriceOracle } from \"./TTrustPriceOracle.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TTrustMarketCapPredictionTTrust\n * @notice Prediction market for TTrust token predictions using TTrust as currency\n * @dev Extends functionality with TTrust-specific logic and uses TTrust token for all transactions\n */\ncontract TTrustMarketCapPredictionTTrust is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error TTrustMarketCapPredictionTTrust__MarketNotResolved();\n    error TTrustMarketCapPredictionTTrust__MarketAlreadyResolved();\n    error TTrustMarketCapPredictionTTrust__DeadlinePassed();\n    error TTrustMarketCapPredictionTTrust__DeadlineNotReached();\n    error TTrustMarketCapPredictionTTrust__InvalidTargetValue();\n    error TTrustMarketCapPredictionTTrust__OracleDataStale();\n    error TTrustMarketCapPredictionTTrust__InvalidPredictionType();\n\n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n\n    enum PredictionType {\n        MARKET_CAP_ABOVE,     // Market cap will be above target\n        MARKET_CAP_BELOW,     // Market cap will be below target\n        PRICE_ABOVE,          // Price will be above target\n        PRICE_BELOW           // Price will be below target\n    }\n\n    struct PredictionDetails {\n        PredictionType predictionType;\n        uint256 targetValue;        // Target market cap or price (18 decimals)\n        uint256 deadline;           // When prediction expires\n        string description;         // Human readable description\n        bool isResolved;           // Has this prediction been resolved\n        bool targetReached;        // Did target get reached\n        uint256 resolutionValue;   // Actual value at resolution time\n        uint256 resolutionTime;    // When it was resolved\n    }\n\n    // Core prediction market contract (handles token trading with TTrust)\n    PredictionMarketTTrust public immutable predictionMarket;\n\n    // Oracle for TTrust price/market cap data\n    TTrustPriceOracle public immutable priceOracle;\n\n    // TTrust token contract\n    IERC20 public immutable ttrustToken;\n\n    // Prediction details\n    PredictionDetails public prediction;\n\n    uint256 public constant PRECISION = 1e18;\n    uint256 public constant RESOLUTION_BUFFER = 1 hours; // Grace period after deadline\n\n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n\n    event PredictionCreated(\n        PredictionType indexed predictionType,\n        uint256 indexed targetValue,\n        uint256 indexed deadline,\n        string description\n    );\n\n    event PredictionResolved(\n        bool indexed targetReached,\n        uint256 actualValue,\n        uint256 targetValue,\n        uint256 resolutionTime\n    );\n\n    event EmergencyResolution(\n        bool targetReached,\n        string reason\n    );\n\n    /////////////////\n    /// Modifiers ///\n    /////////////////\n\n    modifier beforeDeadline() {\n        if (block.timestamp >= prediction.deadline) {\n            revert TTrustMarketCapPredictionTTrust__DeadlinePassed();\n        }\n        _;\n    }\n\n    modifier afterDeadline() {\n        if (block.timestamp < prediction.deadline + RESOLUTION_BUFFER) {\n            revert TTrustMarketCapPredictionTTrust__DeadlineNotReached();\n        }\n        _;\n    }\n\n    modifier notResolved() {\n        if (prediction.isResolved) {\n            revert TTrustMarketCapPredictionTTrust__MarketAlreadyResolved();\n        }\n        _;\n    }\n\n    modifier resolved() {\n        if (!prediction.isResolved) {\n            revert TTrustMarketCapPredictionTTrust__MarketNotResolved();\n        }\n        _;\n    }\n\n    //////////////////\n    ////Constructor///\n    //////////////////\n\n    constructor(\n        address _liquidityProvider,\n        address _priceOracle,\n        address _ttrustToken,\n        PredictionType _predictionType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _initialTokenValue,\n        uint8 _initialYesProbability,\n        uint8 _percentageToLock,\n        uint256 _initialTTrustLiquidity\n    ) Ownable(_liquidityProvider) {\n        \n        if (_targetValue == 0) {\n            revert TTrustMarketCapPredictionTTrust__InvalidTargetValue();\n        }\n\n        if (_deadline <= block.timestamp) {\n            revert TTrustMarketCapPredictionTTrust__DeadlinePassed();\n        }\n\n        // Set oracle and TTrust token\n        priceOracle = TTrustPriceOracle(_priceOracle);\n        ttrustToken = IERC20(_ttrustToken);\n\n        // Store prediction details\n        prediction = PredictionDetails({\n            predictionType: _predictionType,\n            targetValue: _targetValue,\n            deadline: _deadline,\n            description: _description,\n            isResolved: false,\n            targetReached: false,\n            resolutionValue: 0,\n            resolutionTime: 0\n        });\n\n        // Create underlying prediction market with TTrust\n        string memory question = _buildQuestionString(_predictionType, _targetValue, _deadline, _description);\n\n        predictionMarket = new PredictionMarketTTrust(\n            _liquidityProvider,\n            address(this), // This contract acts as oracle\n            _ttrustToken,\n            question,\n            _initialTokenValue,\n            _initialYesProbability,\n            _percentageToLock,\n            _initialTTrustLiquidity\n        );\n\n        emit PredictionCreated(_predictionType, _targetValue, _deadline, _description);\n    }\n\n    /////////////////\n    /// Functions ///\n    /////////////////\n\n    /**\n     * @notice Buy prediction tokens with TTrust (YES = target will be reached, NO = target won't be reached)\n     */\n    function buyTokens(PredictionMarketTTrust.Outcome _outcome, uint256 _amountTokenToBuy) \n        external \n        beforeDeadline\n        notResolved\n    {\n        predictionMarket.buyTokensWithTTrust(_outcome, _amountTokenToBuy);\n    }\n\n    /**\n     * @notice Sell prediction tokens for TTrust\n     */\n    function sellTokens(PredictionMarketTTrust.Outcome _outcome, uint256 _tradingAmount)\n        external\n        beforeDeadline\n        notResolved\n    {\n        predictionMarket.sellTokensForTTrust(_outcome, _tradingAmount);\n    }\n\n    /**\n     * @notice Resolve the prediction by checking current TTrust data\n     */\n    function resolvePrediction() external afterDeadline notResolved {\n        \n        // Get current data from oracle\n        (uint256 currentValue, uint256 timestamp) = _getCurrentValue();\n\n        // Check if oracle data is fresh enough\n        if (block.timestamp - timestamp > 2 hours) {\n            revert TTrustMarketCapPredictionTTrust__OracleDataStale();\n        }\n\n        // Determine if target was reached\n        bool targetReached = _evaluateTarget(currentValue);\n\n        // Update prediction state\n        prediction.isResolved = true;\n        prediction.targetReached = targetReached;\n        prediction.resolutionValue = currentValue;\n        prediction.resolutionTime = block.timestamp;\n\n        // Report to underlying prediction market\n        PredictionMarketTTrust.Outcome winningOutcome = targetReached ? \n            PredictionMarketTTrust.Outcome.YES : \n            PredictionMarketTTrust.Outcome.NO;\n            \n        predictionMarket.report(winningOutcome);\n\n        emit PredictionResolved(targetReached, currentValue, prediction.targetValue, block.timestamp);\n    }\n\n    /**\n     * @notice Emergency resolution by owner (in case of oracle issues)\n     */\n    function emergencyResolve(bool _targetReached, string memory _reason) \n        external \n        onlyOwner \n        notResolved \n    {\n        prediction.isResolved = true;\n        prediction.targetReached = _targetReached;\n        prediction.resolutionTime = block.timestamp;\n\n        PredictionMarketTTrust.Outcome winningOutcome = _targetReached ? \n            PredictionMarketTTrust.Outcome.YES : \n            PredictionMarketTTrust.Outcome.NO;\n            \n        predictionMarket.report(winningOutcome);\n\n        emit EmergencyResolution(_targetReached, _reason);\n    }\n\n    /**\n     * @notice Redeem winning tokens after resolution\n     */\n    function redeemWinningTokens(uint256 _amount) external resolved {\n        predictionMarket.redeemWinningTokens(_amount);\n    }\n\n    /**\n     * @notice Owner can withdraw profits after resolution\n     */\n    function withdrawProfits() external onlyOwner resolved {\n        predictionMarket.resolveMarketAndWithdraw();\n    }\n\n    /////////////////////////\n    /// Internal Functions //\n    /////////////////////////\n\n    /**\n     * @dev Get current value based on prediction type\n     */\n    function _getCurrentValue() internal view returns (uint256 value, uint256 timestamp) {\n        if (prediction.predictionType == PredictionType.MARKET_CAP_ABOVE || \n            prediction.predictionType == PredictionType.MARKET_CAP_BELOW) {\n            return priceOracle.getMarketCap();\n        } else {\n            return priceOracle.getPrice();\n        }\n    }\n\n    /**\n     * @dev Evaluate if target was reached based on prediction type\n     */\n    function _evaluateTarget(uint256 currentValue) internal view returns (bool) {\n        if (prediction.predictionType == PredictionType.MARKET_CAP_ABOVE || \n            prediction.predictionType == PredictionType.PRICE_ABOVE) {\n            return currentValue >= prediction.targetValue;\n        } else {\n            return currentValue <= prediction.targetValue;\n        }\n    }\n\n    /**\n     * @dev Build human-readable question string\n     */\n    function _buildQuestionString(\n        PredictionType _type,\n        uint256 _target,\n        uint256 _deadline,\n        string memory _description\n    ) internal pure returns (string memory) {\n        // This is a simplified version - in production you'd format the numbers properly\n        if (_type == PredictionType.MARKET_CAP_ABOVE) {\n            return string(abi.encodePacked(\"Will TTrust market cap exceed target by deadline? \", _description));\n        } else if (_type == PredictionType.MARKET_CAP_BELOW) {\n            return string(abi.encodePacked(\"Will TTrust market cap stay below target by deadline? \", _description));\n        } else if (_type == PredictionType.PRICE_ABOVE) {\n            return string(abi.encodePacked(\"Will TTrust price exceed target by deadline? \", _description));\n        } else {\n            return string(abi.encodePacked(\"Will TTrust price stay below target by deadline? \", _description));\n        }\n    }\n\n    /////////////////////////\n    /// View Functions //////\n    /////////////////////////\n\n    /**\n     * @notice Get current TTrust metrics for display\n     */\n    function getCurrentTTrustData() \n        external \n        view \n        returns (\n            uint256 currentPrice,\n            uint256 currentMarketCap,\n            uint256 lastUpdate,\n            bool isStale\n        ) \n    {\n        try priceOracle.getPrice() returns (uint256 price, uint256 timestamp) {\n            currentPrice = price;\n            lastUpdate = timestamp;\n            \n            try priceOracle.getMarketCap() returns (uint256 marketCap, uint256 mcTimestamp) {\n                currentMarketCap = marketCap;\n                if (mcTimestamp > lastUpdate) lastUpdate = mcTimestamp;\n            } catch {\n                currentMarketCap = 0;\n            }\n            \n            isStale = (block.timestamp - lastUpdate) > 2 hours;\n        } catch {\n            currentPrice = 0;\n            currentMarketCap = 0;\n            lastUpdate = 0;\n            isStale = true;\n        }\n    }\n\n    /**\n     * @notice Get complete prediction information\n     */\n    function getPredictionInfo()\n        external\n        view\n        returns (\n            PredictionType predictionType,\n            uint256 targetValue,\n            uint256 deadline,\n            string memory description,\n            bool isResolved,\n            bool targetReached,\n            uint256 resolutionValue,\n            uint256 resolutionTime,\n            address predictionMarketAddress\n        )\n    {\n        return (\n            prediction.predictionType,\n            prediction.targetValue,\n            prediction.deadline,\n            prediction.description,\n            prediction.isResolved,\n            prediction.targetReached,\n            prediction.resolutionValue,\n            prediction.resolutionTime,\n            address(predictionMarket)\n        );\n    }\n\n    /**\n     * @notice Get trading information from underlying market\n     */\n    function getTradingInfo()\n        external\n        view\n        returns (\n            uint256 yesTokenPrice,\n            uint256 noTokenPrice,\n            uint256 yesTokenReserve,\n            uint256 noTokenReserve,\n            address yesToken,\n            address noToken\n        )\n    {\n        yesTokenPrice = predictionMarket.getBuyPriceInTTrust(PredictionMarketTTrust.Outcome.YES, 1 ether);\n        noTokenPrice = predictionMarket.getBuyPriceInTTrust(PredictionMarketTTrust.Outcome.NO, 1 ether);\n        \n        (,,,, ,yesTokenReserve, noTokenReserve, , yesToken, noToken, , , , , , , ) = predictionMarket.getPrediction();\n    }\n\n    /**\n     * @notice Check if prediction can be resolved\n     */\n    function canResolve() external view returns (bool) {\n        return !prediction.isResolved && \n               block.timestamp >= prediction.deadline + RESOLUTION_BUFFER &&\n               priceOracle.isPriceValid();\n    }\n\n    /**\n     * @notice Get time left until deadline\n     */\n    function getTimeToDeadline() external view returns (uint256) {\n        if (block.timestamp >= prediction.deadline) {\n            return 0;\n        }\n        return prediction.deadline - block.timestamp;\n    }\n}"
    },
    "contracts/TTrustPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { AggregatorV3Interface } from \"./interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title TTrustPriceOracle\n * @notice Oracle contract to get TTrust price data from multiple sources\n * @dev Can integrate with DEX prices, external oracles, or manual price feeds\n */\ncontract TTrustPriceOracle is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error TTrustPriceOracle__PriceStale();\n    error TTrustPriceOracle__InvalidPrice();\n    error TTrustPriceOracle__OnlyTrustedUpdater();\n    error TTrustPriceOracle__InvalidDEXAddress();\n    \n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n    \n    struct PriceData {\n        uint256 price;          // Price in USD (18 decimals)\n        uint256 timestamp;      // Last update timestamp\n        uint256 marketCap;      // Market cap in USD (18 decimals)\n        bool isValid;           // Is this price valid\n    }\n    \n    PriceData public currentPrice;\n    \n    uint256 public constant PRICE_STALENESS_THRESHOLD = 1 hours;\n    uint256 public constant PRECISION = 1e18;\n    \n    // Trusted price updaters (can be set to external oracles or bots)\n    mapping(address => bool) public trustedUpdaters;\n    \n    // DEX contract address for getting prices from liquidity pools\n    address public dexRouter;\n    address public ttustIntuitPair;\n    \n    // Backup price feeds (Chainlink style)\n    AggregatorV3Interface public backupPriceFeed;\n    \n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n    \n    event PriceUpdated(uint256 indexed price, uint256 indexed marketCap, uint256 timestamp, address updater);\n    event TrustedUpdaterSet(address indexed updater, bool trusted);\n    event DEXRouterSet(address indexed router, address indexed pair);\n    event BackupPriceFeedSet(address indexed priceFeed);\n    \n    /////////////////\n    /// Modifiers ///\n    /////////////////\n    \n    modifier onlyTrustedUpdater() {\n        if (!trustedUpdaters[msg.sender] && msg.sender != owner()) {\n            revert TTrustPriceOracle__OnlyTrustedUpdater();\n        }\n        _;\n    }\n    \n    //////////////////\n    ////Constructor///\n    //////////////////\n    \n    constructor(\n        address _owner,\n        uint256 _initialPrice,\n        uint256 _initialMarketCap\n    ) Ownable(_owner) {\n        // Set initial price data\n        currentPrice = PriceData({\n            price: _initialPrice,\n            timestamp: block.timestamp,\n            marketCap: _initialMarketCap,\n            isValid: true\n        });\n        \n        // Owner is automatically a trusted updater\n        trustedUpdaters[_owner] = true;\n        \n        emit PriceUpdated(_initialPrice, _initialMarketCap, block.timestamp, msg.sender);\n    }\n    \n    /////////////////\n    /// Functions ///\n    /////////////////\n    \n    /**\n     * @notice Update TTrust price manually (for trusted updaters)\n     * @param _price New price in USD (18 decimals)\n     * @param _marketCap New market cap in USD (18 decimals)\n     */\n    function updatePrice(uint256 _price, uint256 _marketCap) \n        external \n        onlyTrustedUpdater \n    {\n        if (_price == 0) {\n            revert TTrustPriceOracle__InvalidPrice();\n        }\n        \n        currentPrice = PriceData({\n            price: _price,\n            timestamp: block.timestamp,\n            marketCap: _marketCap,\n            isValid: true\n        });\n        \n        emit PriceUpdated(_price, _marketCap, block.timestamp, msg.sender);\n    }\n    \n    /**\n     * @notice Get current TTrust price\n     * @return price Current price in USD (18 decimals)\n     * @return timestamp Last update timestamp\n     */\n    function getPrice() external view returns (uint256 price, uint256 timestamp) {\n        if (!isPriceValid()) {\n            revert TTrustPriceOracle__PriceStale();\n        }\n        \n        return (currentPrice.price, currentPrice.timestamp);\n    }\n    \n    /**\n     * @notice Get current TTrust market cap\n     * @return marketCap Current market cap in USD (18 decimals)\n     * @return timestamp Last update timestamp\n     */\n    function getMarketCap() external view returns (uint256 marketCap, uint256 timestamp) {\n        if (!isPriceValid()) {\n            revert TTrustPriceOracle__PriceStale();\n        }\n        \n        return (currentPrice.marketCap, currentPrice.timestamp);\n    }\n    \n    /**\n     * @notice Check if current price is valid (not stale)\n     * @return bool True if price is valid\n     */\n    function isPriceValid() public view returns (bool) {\n        return currentPrice.isValid && \n               (block.timestamp - currentPrice.timestamp) <= PRICE_STALENESS_THRESHOLD;\n    }\n    \n    /**\n     * @notice Get price from DEX (if configured)\n     * @return price Price from DEX\n     */\n    function getPriceFromDEX() external view returns (uint256 price) {\n        // This would integrate with the existing DEX to get TTrust price\n        // Implementation depends on the DEX structure\n        if (dexRouter == address(0)) {\n            return 0;\n        }\n        \n        // TODO: Implement actual DEX price fetching\n        // For now, return current price as fallback\n        return currentPrice.price;\n    }\n    \n    /////////////////////////\n    /// Admin Functions ////\n    /////////////////////////\n    \n    /**\n     * @notice Set trusted updater status\n     * @param _updater Address to set trust status for\n     * @param _trusted Whether this address is trusted\n     */\n    function setTrustedUpdater(address _updater, bool _trusted) external onlyOwner {\n        trustedUpdaters[_updater] = _trusted;\n        emit TrustedUpdaterSet(_updater, _trusted);\n    }\n    \n    /**\n     * @notice Set DEX router and pair addresses for price fetching\n     * @param _router DEX router address\n     * @param _pair TTrust/INTUIT pair address\n     */\n    function setDEXAddresses(address _router, address _pair) external onlyOwner {\n        if (_router == address(0) || _pair == address(0)) {\n            revert TTrustPriceOracle__InvalidDEXAddress();\n        }\n        \n        dexRouter = _router;\n        ttustIntuitPair = _pair;\n        \n        emit DEXRouterSet(_router, _pair);\n    }\n    \n    /**\n     * @notice Set backup price feed (Chainlink style)\n     * @param _priceFeed Chainlink price feed address\n     */\n    function setBackupPriceFeed(address _priceFeed) external onlyOwner {\n        backupPriceFeed = AggregatorV3Interface(_priceFeed);\n        emit BackupPriceFeedSet(_priceFeed);\n    }\n    \n    /**\n     * @notice Emergency function to invalidate current price\n     */\n    function invalidatePrice() external onlyOwner {\n        currentPrice.isValid = false;\n    }\n    \n    /////////////////////////\n    /// Getter Functions ///\n    /////////////////////////\n    \n    /**\n     * @notice Get all price data\n     */\n    function getAllPriceData() \n        external \n        view \n        returns (\n            uint256 price,\n            uint256 timestamp,\n            uint256 marketCap,\n            bool isValid,\n            bool isStale\n        ) \n    {\n        price = currentPrice.price;\n        timestamp = currentPrice.timestamp;\n        marketCap = currentPrice.marketCap;\n        isValid = currentPrice.isValid;\n        isStale = !isPriceValid();\n    }\n}"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}