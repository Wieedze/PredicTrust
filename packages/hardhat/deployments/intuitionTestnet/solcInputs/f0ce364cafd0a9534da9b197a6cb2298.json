{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/PredictionFactoryTTrustSimple.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { SimpleMarket } from \"./SimpleMarket.sol\";\nimport { TTrustPriceOracle } from \"./TTrustPriceOracle.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title PredictionFactoryTTrustSimple\n * @notice Simplified factory contract for creating TTrust-based prediction markets\n */\ncontract PredictionFactoryTTrustSimple is Ownable {\n    \n    enum PredictionType {\n        MARKET_CAP_ABOVE,\n        MARKET_CAP_BELOW,\n        PRICE_ABOVE,\n        PRICE_BELOW\n    }\n    \n    // TTrust token contract\n    IERC20 public immutable ttrustToken;\n    \n    // Oracle\n    TTrustPriceOracle public ttustPriceOracle;\n    \n    // Simple market registry\n    address[] public allMarkets;\n    uint256 public marketCount;\n    \n    // Settings\n    uint256 public minimumLiquidity = 1e17; // 0.1 TTrust minimum\n    uint256 public creationFee = 1e15; // 0.001 TTrust creation fee\n    \n    event TTrustMarketCreated(\n        address indexed marketAddress,\n        address indexed creator,\n        PredictionType indexed predictionType,\n        uint256 targetValue,\n        uint256 deadline,\n        string description\n    );\n    \n    modifier validLiquidity(uint256 _liquidity) {\n        require(_liquidity >= minimumLiquidity, \"Insufficient liquidity\");\n        _;\n    }\n    \n    modifier validDeadline(uint256 _deadline) {\n        require(_deadline > block.timestamp, \"Invalid deadline\");\n        _;\n    }\n    \n    constructor(\n        address _owner,\n        address _ttrustToken,\n        address _ttustPriceOracle\n    ) Ownable(_owner) {\n        ttrustToken = IERC20(_ttrustToken);\n        \n        if (_ttustPriceOracle != address(0)) {\n            ttustPriceOracle = TTrustPriceOracle(_ttustPriceOracle);\n        }\n    }\n    \n    /**\n     * @notice Create a new TTrust prediction market\n     */\n    function createTTrustMarket(\n        PredictionType _predictionType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _customTokenValue,\n        uint8 _customProbability,\n        uint256 _liquidityAmount\n    )\n        external\n        validLiquidity(_liquidityAmount)\n        validDeadline(_deadline)\n        returns (address marketAddress)\n    {\n        require(address(ttustPriceOracle) != address(0), \"Oracle not set\");\n        require(_targetValue > 0, \"Invalid target value\");\n        \n        // Check TTrust allowance and transfer tokens\n        require(ttrustToken.allowance(msg.sender, address(this)) >= _liquidityAmount, \"Insufficient allowance\");\n        require(ttrustToken.transferFrom(msg.sender, address(this), _liquidityAmount), \"Transfer failed\");\n        \n        // Calculate liquidity\n        uint256 actualLiquidity = _liquidityAmount - creationFee;\n        \n        // Create the market\n        SimpleMarket.PredictionType marketPredictionType = SimpleMarket.PredictionType(uint8(_predictionType));\n        \n        SimpleMarket market = new SimpleMarket(\n            msg.sender,\n            address(ttrustToken),\n            marketPredictionType,\n            _targetValue,\n            _deadline,\n            _description,\n            actualLiquidity\n        );\n        \n        marketAddress = address(market);\n        \n        // Register market\n        allMarkets.push(marketAddress);\n        marketCount++;\n        \n        emit TTrustMarketCreated(\n            marketAddress,\n            msg.sender,\n            _predictionType,\n            _targetValue,\n            _deadline,\n            _description\n        );\n    }\n    \n    /**\n     * @notice Get market count\n     */\n    function getMarketCount() external view returns (uint256) {\n        return marketCount;\n    }\n    \n    /**\n     * @notice Get active markets (simple pagination)\n     */\n    function getActiveMarkets(uint256 _offset, uint256 _limit) \n        external \n        view \n        returns (address[] memory markets, uint256 total) \n    {\n        total = marketCount;\n        \n        if (_offset >= total) {\n            return (new address[](0), total);\n        }\n        \n        uint256 end = _offset + _limit;\n        if (end > total) {\n            end = total;\n        }\n        \n        markets = new address[](end - _offset);\n        for (uint256 i = _offset; i < end; i++) {\n            markets[i - _offset] = allMarkets[i];\n        }\n    }\n    \n    /**\n     * @notice Set oracle address\n     */\n    function setTTrustPriceOracle(address _oracle) external onlyOwner {\n        ttustPriceOracle = TTrustPriceOracle(_oracle);\n    }\n    \n    /**\n     * @notice Update fees\n     */\n    function setCreationFee(uint256 _fee) external onlyOwner {\n        creationFee = _fee;\n    }\n    \n    /**\n     * @notice Withdraw collected fees\n     */\n    function withdrawFees() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n}"
    },
    "contracts/PredictionMarketTTrust.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// Placeholder contract for compilation\ncontract PredictionMarketTTrust {\n    // Empty placeholder\n}"
    },
    "contracts/SimpleMarket.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title SimpleMarket\n * @notice Simple prediction market contract\n */\ncontract SimpleMarket is Ownable {\n    \n    enum PredictionType {\n        MARKET_CAP_ABOVE,\n        MARKET_CAP_BELOW,\n        PRICE_ABOVE,\n        PRICE_BELOW\n    }\n    \n    struct MarketDetails {\n        PredictionType predictionType;\n        uint256 targetValue;\n        uint256 deadline;\n        string description;\n        address creator;\n        bool isResolved;\n        bool targetReached;\n        uint256 liquidityAmount;\n    }\n    \n    MarketDetails public marketDetails;\n    IERC20 public ttrustToken;\n    \n    constructor(\n        address _creator,\n        address _ttrustToken,\n        PredictionType _predictionType,\n        uint256 _targetValue,\n        uint256 _deadline,\n        string memory _description,\n        uint256 _liquidityAmount\n    ) Ownable(_creator) {\n        marketDetails = MarketDetails({\n            predictionType: _predictionType,\n            targetValue: _targetValue,\n            deadline: _deadline,\n            description: _description,\n            creator: _creator,\n            isResolved: false,\n            targetReached: false,\n            liquidityAmount: _liquidityAmount\n        });\n        \n        ttrustToken = IERC20(_ttrustToken);\n    }\n    \n    function getMarketInfo() external view returns (MarketDetails memory) {\n        return marketDetails;\n    }\n}"
    },
    "contracts/TTrustPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { AggregatorV3Interface } from \"./interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title TTrustPriceOracle\n * @notice Oracle contract to get TTrust price data from multiple sources\n * @dev Can integrate with DEX prices, external oracles, or manual price feeds\n */\ncontract TTrustPriceOracle is Ownable {\n    \n    /////////////////\n    /// Errors //////\n    /////////////////\n    \n    error TTrustPriceOracle__PriceStale();\n    error TTrustPriceOracle__InvalidPrice();\n    error TTrustPriceOracle__OnlyTrustedUpdater();\n    error TTrustPriceOracle__InvalidDEXAddress();\n    \n    //////////////////////////\n    /// State Variables //////\n    //////////////////////////\n    \n    struct PriceData {\n        uint256 price;          // Price in USD (18 decimals)\n        uint256 timestamp;      // Last update timestamp\n        uint256 marketCap;      // Market cap in USD (18 decimals)\n        bool isValid;           // Is this price valid\n    }\n    \n    PriceData public currentPrice;\n    \n    uint256 public constant PRICE_STALENESS_THRESHOLD = 1 hours;\n    uint256 public constant PRECISION = 1e18;\n    \n    // Trusted price updaters (can be set to external oracles or bots)\n    mapping(address => bool) public trustedUpdaters;\n    \n    // DEX contract address for getting prices from liquidity pools\n    address public dexRouter;\n    address public ttustIntuitPair;\n    \n    // Backup price feeds (Chainlink style)\n    AggregatorV3Interface public backupPriceFeed;\n    \n    /////////////////////////\n    /// Events //////\n    /////////////////////////\n    \n    event PriceUpdated(uint256 indexed price, uint256 indexed marketCap, uint256 timestamp, address updater);\n    event TrustedUpdaterSet(address indexed updater, bool trusted);\n    event DEXRouterSet(address indexed router, address indexed pair);\n    event BackupPriceFeedSet(address indexed priceFeed);\n    \n    /////////////////\n    /// Modifiers ///\n    /////////////////\n    \n    modifier onlyTrustedUpdater() {\n        if (!trustedUpdaters[msg.sender] && msg.sender != owner()) {\n            revert TTrustPriceOracle__OnlyTrustedUpdater();\n        }\n        _;\n    }\n    \n    //////////////////\n    ////Constructor///\n    //////////////////\n    \n    constructor(\n        address _owner,\n        uint256 _initialPrice,\n        uint256 _initialMarketCap\n    ) Ownable(_owner) {\n        // Set initial price data\n        currentPrice = PriceData({\n            price: _initialPrice,\n            timestamp: block.timestamp,\n            marketCap: _initialMarketCap,\n            isValid: true\n        });\n        \n        // Owner is automatically a trusted updater\n        trustedUpdaters[_owner] = true;\n        \n        emit PriceUpdated(_initialPrice, _initialMarketCap, block.timestamp, msg.sender);\n    }\n    \n    /////////////////\n    /// Functions ///\n    /////////////////\n    \n    /**\n     * @notice Update TTrust price manually (for trusted updaters)\n     * @param _price New price in USD (18 decimals)\n     * @param _marketCap New market cap in USD (18 decimals)\n     */\n    function updatePrice(uint256 _price, uint256 _marketCap) \n        external \n        onlyTrustedUpdater \n    {\n        if (_price == 0) {\n            revert TTrustPriceOracle__InvalidPrice();\n        }\n        \n        currentPrice = PriceData({\n            price: _price,\n            timestamp: block.timestamp,\n            marketCap: _marketCap,\n            isValid: true\n        });\n        \n        emit PriceUpdated(_price, _marketCap, block.timestamp, msg.sender);\n    }\n    \n    /**\n     * @notice Get current TTrust price\n     * @return price Current price in USD (18 decimals)\n     * @return timestamp Last update timestamp\n     */\n    function getPrice() external view returns (uint256 price, uint256 timestamp) {\n        if (!isPriceValid()) {\n            revert TTrustPriceOracle__PriceStale();\n        }\n        \n        return (currentPrice.price, currentPrice.timestamp);\n    }\n    \n    /**\n     * @notice Get current TTrust market cap\n     * @return marketCap Current market cap in USD (18 decimals)\n     * @return timestamp Last update timestamp\n     */\n    function getMarketCap() external view returns (uint256 marketCap, uint256 timestamp) {\n        if (!isPriceValid()) {\n            revert TTrustPriceOracle__PriceStale();\n        }\n        \n        return (currentPrice.marketCap, currentPrice.timestamp);\n    }\n    \n    /**\n     * @notice Check if current price is valid (not stale)\n     * @return bool True if price is valid\n     */\n    function isPriceValid() public view returns (bool) {\n        return currentPrice.isValid && \n               (block.timestamp - currentPrice.timestamp) <= PRICE_STALENESS_THRESHOLD;\n    }\n    \n    /**\n     * @notice Get price from DEX (if configured)\n     * @return price Price from DEX\n     */\n    function getPriceFromDEX() external view returns (uint256 price) {\n        // This would integrate with the existing DEX to get TTrust price\n        // Implementation depends on the DEX structure\n        if (dexRouter == address(0)) {\n            return 0;\n        }\n        \n        // TODO: Implement actual DEX price fetching\n        // For now, return current price as fallback\n        return currentPrice.price;\n    }\n    \n    /////////////////////////\n    /// Admin Functions ////\n    /////////////////////////\n    \n    /**\n     * @notice Set trusted updater status\n     * @param _updater Address to set trust status for\n     * @param _trusted Whether this address is trusted\n     */\n    function setTrustedUpdater(address _updater, bool _trusted) external onlyOwner {\n        trustedUpdaters[_updater] = _trusted;\n        emit TrustedUpdaterSet(_updater, _trusted);\n    }\n    \n    /**\n     * @notice Set DEX router and pair addresses for price fetching\n     * @param _router DEX router address\n     * @param _pair TTrust/INTUIT pair address\n     */\n    function setDEXAddresses(address _router, address _pair) external onlyOwner {\n        if (_router == address(0) || _pair == address(0)) {\n            revert TTrustPriceOracle__InvalidDEXAddress();\n        }\n        \n        dexRouter = _router;\n        ttustIntuitPair = _pair;\n        \n        emit DEXRouterSet(_router, _pair);\n    }\n    \n    /**\n     * @notice Set backup price feed (Chainlink style)\n     * @param _priceFeed Chainlink price feed address\n     */\n    function setBackupPriceFeed(address _priceFeed) external onlyOwner {\n        backupPriceFeed = AggregatorV3Interface(_priceFeed);\n        emit BackupPriceFeedSet(_priceFeed);\n    }\n    \n    /**\n     * @notice Emergency function to invalidate current price\n     */\n    function invalidatePrice() external onlyOwner {\n        currentPrice.isValid = false;\n    }\n    \n    /////////////////////////\n    /// Getter Functions ///\n    /////////////////////////\n    \n    /**\n     * @notice Get all price data\n     */\n    function getAllPriceData() \n        external \n        view \n        returns (\n            uint256 price,\n            uint256 timestamp,\n            uint256 marketCap,\n            bool isValid,\n            bool isStale\n        ) \n    {\n        price = currentPrice.price;\n        timestamp = currentPrice.timestamp;\n        marketCap = currentPrice.marketCap;\n        isValid = currentPrice.isValid;\n        isStale = !isPriceValid();\n    }\n}"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}